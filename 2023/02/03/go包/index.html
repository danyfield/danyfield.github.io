<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>go包 | dany's blog</title><meta name="author" content="dany"><meta name="copyright" content="dany"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Archivetar(实现tar格式压缩文件的存取)&#x2F;*ConstantsVariablestype Format	func (f Format) String() stringtype Header	func FileInfoHeader(fi fs.FileInfo,link string) (*Header,error)	func (h *Header) FileInfo() fs.File">
<meta property="og:type" content="article">
<meta property="og:title" content="go包">
<meta property="og:url" content="https://danyfield.github.io/2023/02/03/go%E5%8C%85/index.html">
<meta property="og:site_name" content="dany&#39;s blog">
<meta property="og:description" content="Archivetar(实现tar格式压缩文件的存取)&#x2F;*ConstantsVariablestype Format	func (f Format) String() stringtype Header	func FileInfoHeader(fi fs.FileInfo,link string) (*Header,error)	func (h *Header) FileInfo() fs.File">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://danyfield.github.io/img/avatar.png">
<meta property="article:published_time" content="2023-02-03T06:03:57.000Z">
<meta property="article:modified_time" content="2023-03-07T13:57:02.255Z">
<meta property="article:author" content="dany">
<meta property="article:tag" content="go">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://danyfield.github.io/img/avatar.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://danyfield.github.io/2023/02/03/go%E5%8C%85/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'go包',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-07 21:57:02'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/mouse.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/custom.css"  media="defer" onload="this.media='all'"><meta name="generator" content="Hexo 5.4.2"></head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouye"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-mulu"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-shijianxian"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-biaoqian"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-fenlei"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-xiuxiankafeiyule"></i><span> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw iconfont icon-yinle"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/documents/"><i class="fa-fw iconfont icon-wendang"></i><span> 文档</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw iconfont icon-shipin"></i><span> 视频</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-guanyu"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/index.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="dany's blog"><span class="site-name">dany's blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouye"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-mulu"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-shijianxian"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-biaoqian"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-fenlei"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-xiuxiankafeiyule"></i><span> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw iconfont icon-yinle"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/documents/"><i class="fa-fw iconfont icon-wendang"></i><span> 文档</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw iconfont icon-shipin"></i><span> 视频</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-guanyu"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">go包</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-02-03T06:03:57.000Z" title="发表于 2023-02-03 14:03:57">2023-02-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-07T13:57:02.255Z" title="更新于 2023-03-07 21:57:02">2023-03-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/go/">go</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">13.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>63分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="go包"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="Archive"><a href="#Archive" class="headerlink" title="Archive"></a>Archive</h3><h4 id="tar-实现tar格式压缩文件的存取"><a href="#tar-实现tar格式压缩文件的存取" class="headerlink" title="tar(实现tar格式压缩文件的存取)"></a>tar(实现tar格式压缩文件的存取)</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Constants</span></span><br><span class="line"><span class="comment">Variables</span></span><br><span class="line"><span class="comment">type Format</span></span><br><span class="line"><span class="comment">	func (f Format) String() string</span></span><br><span class="line"><span class="comment">type Header</span></span><br><span class="line"><span class="comment">	func FileInfoHeader(fi fs.FileInfo,link string) (*Header,error)</span></span><br><span class="line"><span class="comment">	func (h *Header) FileInfo() fs.FileInfo</span></span><br><span class="line"><span class="comment">type Reader</span></span><br><span class="line"><span class="comment">	func NewReader(r io.Reader) *Reader</span></span><br><span class="line"><span class="comment">	func (tr *Reader) Next() (*Header,error)</span></span><br><span class="line"><span class="comment">	func (tr *Reader) Read(b []byte) (int,error)</span></span><br><span class="line"><span class="comment">type Writer</span></span><br><span class="line"><span class="comment">	func NewWriter(w io.Writer) *Writer</span></span><br><span class="line"><span class="comment">	func (tw *Writer) Close() error</span></span><br><span class="line"><span class="comment">	func (tw *Writer) Flush() error</span></span><br><span class="line"><span class="comment">	func (tw *Writer) Write(b []byte) (int,error)</span></span><br><span class="line"><span class="comment">	func (tw *Writer) WriteHeader(hdr *Header) error</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h5 id="Header：表示tar文件里单个头"><a href="#Header：表示tar文件里单个头" class="headerlink" title="Header：表示tar文件里单个头"></a>Header：表示tar文件里单个头</h5><p>*<em>FileInfoHeader(fi fs.FileInfo,link string) (<em>Header,error)</em></em></p>
<p>返回一个根据fi填写了部分字段的Header，若fi描述了一个符号链接，则函数将link参数作为链接目标，若fi描述一个目录，则在名字后加斜杠</p>
<h5 id="Reader：提供对tar档案文件的顺序读取"><a href="#Reader：提供对tar档案文件的顺序读取" class="headerlink" title="Reader：提供对tar档案文件的顺序读取"></a>Reader：提供对tar档案文件的顺序读取</h5><p>*<em>NewReader(r io.Reader) <em>Reader</em></em></p>
<p>创建一个从r读取的Reader</p>
<p>**(tr <em>Reader) Next() (*Header,error)</em>*</p>
<p>转入tar档案文件下一记录，返回下一记录的头域</p>
<p>**(tr <em>Reader) Read(b []byte) (n int,err error)</em>*</p>
<p>从档案文件当前记录读取数据到记录末端返回(0,EOF)，直到调用Next转下一记录</p>
<h5 id="Writer：提供POSIX-1格式的tar档案文件顺序写入"><a href="#Writer：提供POSIX-1格式的tar档案文件顺序写入" class="headerlink" title="Writer：提供POSIX.1格式的tar档案文件顺序写入"></a>Writer：提供POSIX.1格式的tar档案文件顺序写入</h5><p>*<em>NewWriter(w io.Writer) <em>Writer</em></em></p>
<p>创建一个写入w的*Writer</p>
<p>**(tw <em>Writer) WriterHeader(hdr <em>Header) error</em></em></p>
<p>写入hdr并准备接受文件内容，Header.Size取决于下一个文件能写入多少字节，若非首次调用本方法会调用Flush，在close后调用会返回ErrWriterAfterClose</p>
<p>**(tw <em>Writer) Write(b []byte) (n int,err error)</em>*</p>
<p>Write向tar档案文件的当前记录中写入数据，若写入数据总数超出上一次调用WriteHeader的参数hdr.Size字节，返回ErrWriteTooLong错误</p>
<p>**(tw <em>Writer) Flush() error</em>*</p>
<p>结束当前文件的写入</p>
<p>**(tw <em>Writer) Close() error</em>*</p>
<p>关闭tar档案文件，将缓冲中未写入下层的io.Writer接口的数据刷新到下层</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//FileInfoHeader</span></span><br><span class="line">    <span class="comment">//func FileInfoHeader(fi fs.FileInfo,link string) (*Header,error)</span></span><br><span class="line">    fileinfo,err := os.Stat(<span class="string">&quot;test.txt&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    	fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">    h,err := tar.FileInfoHeader(fileinfo,<span class="string">&quot;&quot;</span>)</span><br><span class="line">    h.Linkname = <span class="string">&quot;haha&quot;</span></span><br><span class="line">    h.Gname = <span class="string">&quot;test&quot;</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    	fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(h.AccessTime,h.ChangeTime, h.Devmajor, h.Devminor, h.Gid,  h.Gname, h.Linkname, h.ModTime, h.Mode, h.Name, h.Size,h.Typeflag, h.Uid, h.Uname, h.Xattrs)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//FileInfo返回Header对应的文件信息</span></span><br><span class="line">    <span class="comment">//func (h *Header) FileInfo() fs.FileInfo</span></span><br><span class="line">    f,err := os.Open(<span class="string">&quot;sdk/test.tar&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> f.Close()</span><br><span class="line">		</span><br><span class="line">    r := tar.NewReader(f)</span><br><span class="line">	<span class="keyword">for</span> hdr,err := r.Next(); err != io.EOF; hdr,err = r.Next() &#123;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">			</span><br><span class="line">		fileInfo := hdr.FileInfo()</span><br><span class="line">		fmt.Println(fileInfo.Name())</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//转入tar档案文件下一记录，返回下一记录的头域</span></span><br><span class="line">    <span class="comment">//func (tr *Reader) Next() (*Header,error)</span></span><br><span class="line">    <span class="comment">//func (tr *Reader) Read(b []byte) (int,error)</span></span><br><span class="line">    r := tar.NewReader(strings.NewReader(<span class="string">&quot;test.tar&quot;</span>))</span><br><span class="line">    h,err := r.Next()</span><br><span class="line">    fmt.Println(h,err)</span><br><span class="line">    </span><br><span class="line">    n,err := tar.NewReader(strings.NewReader(<span class="string">&quot;test.log&quot;</span>)).Read(<span class="built_in">make</span>([]<span class="type">byte</span>,<span class="number">0</span>))</span><br><span class="line">    fmt.Println(n,err)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Close关闭tar档案文件，会将缓冲中未写入下层的io.Writer接口的数据刷新到下层</span></span><br><span class="line">    <span class="comment">//func (tw *Writer) Close() error</span></span><br><span class="line">    f,err := os.Create(<span class="string">&quot;sdk/demo.tar&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    	fmt.Println(err)</span><br><span class="line">    	<span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> f.Close()</span><br><span class="line">    tw := tar.NewWriter(f)</span><br><span class="line">    <span class="keyword">defer</span> tw.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Zip"><a href="#Zip" class="headerlink" title="Zip"></a>Zip</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Constants</span></span><br><span class="line"><span class="comment">Variables</span></span><br><span class="line"><span class="comment">	func RegisterCompressor(method uint16,comp Compressor)</span></span><br><span class="line"><span class="comment">	func RegisterDecompressor(method unit16,dcomp Decompressor)</span></span><br><span class="line"><span class="comment">	type Compressor </span></span><br><span class="line"><span class="comment">	type Decompressor</span></span><br><span class="line"><span class="comment">	type File</span></span><br><span class="line"><span class="comment">		func (f *File) DataOffset() (offset int64,err error)</span></span><br><span class="line"><span class="comment">		func (f *File) Open() (io.ReadCloser,error)</span></span><br><span class="line"><span class="comment">	type FileHeader</span></span><br><span class="line"><span class="comment">		func FileInfoHeader(fi fs.FileInfo) (*FileHeader,error)</span></span><br><span class="line"><span class="comment">		func (h *FileHeader) FileInfo() fs.FileInfo</span></span><br><span class="line"><span class="comment">		func (h *FileHeader) ModTime() time.Time</span></span><br><span class="line"><span class="comment">		func (h *FileHeader) Mode() (mode fs.FileMode)</span></span><br><span class="line"><span class="comment">		func (h *FileHeader) SetModTime(t time.Time)</span></span><br><span class="line"><span class="comment">		func (h *FileHeader) SetMode(mode fs.FileMode)</span></span><br><span class="line"><span class="comment">	type ReadCloser</span></span><br><span class="line"><span class="comment">		func OpenReader(name string) (*ReadCloser,error)</span></span><br><span class="line"><span class="comment">		func (rc *ReadCloser) Close() error</span></span><br><span class="line"><span class="comment">	type Reader</span></span><br><span class="line"><span class="comment">		func NewReader(r io.ReaderAt,size int64) (*Reader,error)</span></span><br><span class="line"><span class="comment">		func (r *Reader) Open(name string) (fs.File,error)</span></span><br><span class="line"><span class="comment">		func (z *Reader) RegisterDecompressor(method unit16,dcomp Decompressor)</span></span><br><span class="line"><span class="comment">	type Writer</span></span><br><span class="line"><span class="comment">		func NewWriter(w io.Writer) *Writer</span></span><br><span class="line"><span class="comment">		func (w *Writer) Close() error</span></span><br><span class="line"><span class="comment">		func (w *Writer) Crteate(name string) (io.Writer,error)</span></span><br><span class="line"><span class="comment">		func (w *Writer) CreateHeader(fh *FileHeader) (io.Writer,error)</span></span><br><span class="line"><span class="comment">		func (w *Writer) Flush() error</span></span><br><span class="line"><span class="comment">		func (w *Writer) RegisterCompressor(method unit16,comp Compressor)</span></span><br><span class="line"><span class="comment">		func (w *Writer) SetComment(comment string) error</span></span><br><span class="line"><span class="comment">		func (w *Writer) SetOffset(n int64)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h5 id="压缩文件"><a href="#压缩文件" class="headerlink" title="压缩文件"></a>压缩文件</h5><h6 id="读取文件内容并压缩"><a href="#读取文件内容并压缩" class="headerlink" title="读取文件内容并压缩"></a>读取文件内容并压缩</h6><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompressedFile</span><span class="params">(file *os.File,prefix <span class="type">string</span>,zw *zip.Writer)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    info,err := file.Stat()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> || info.IsDir() &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    header,err := zip.FileInfoHeader(info)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    header.Name = prefix + <span class="string">&quot;/&quot;</span> + header.Name</span><br><span class="line">    writer,err := zw.CreateHeader(header)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> _,err = io.Copy(writer,file); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f,_ := os.Open(<span class="string">&quot;test.txt&quot;</span>)</span><br><span class="line">    <span class="comment">//压缩文件</span></span><br><span class="line">    dst,_ := os.Create(<span class="string">&quot;test.zip&quot;</span>)</span><br><span class="line">    zipWriter := zip.NewWriter(dst)</span><br><span class="line">    <span class="keyword">if</span> err := CompressFile(f,<span class="string">&quot;&quot;</span>,zipWriter); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalln(err.Error())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Make sure to check the error on Close.</span></span><br><span class="line">    <span class="keyword">if</span> err := zipWriter.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalln(err.Error())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CompressedFile是将文件内容进行压缩，若想将目录进行压缩则将目录中的文件提取出来然后调用CompressedFile将文件压缩并写入zip.Writer即可：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Compress 压缩文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Compress</span><span class="params">(file *os.File, prefix <span class="type">string</span>, zw *zip.Writer)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    info,err := file.Stat()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若是目录调用CompressedDir</span></span><br><span class="line">    <span class="keyword">if</span> info.IsDir() &#123;</span><br><span class="line">        <span class="keyword">return</span> CompressedDir(file, prefix, zw)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若是文件调用CompressedFile</span></span><br><span class="line">    <span class="keyword">return</span> CompressedFile(file, prefix, zw)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//CompressedDir</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompressedDir</span><span class="params">(file *os.File,prefix <span class="type">string</span>,zw *zip.Writer)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    info,_ := file.Stat()</span><br><span class="line">    prefix = prefix + <span class="string">&quot;/&quot;</span> + info.Name()</span><br><span class="line">    dirInfo,err := file.Readdir(<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _,f := <span class="keyword">range</span> dirInfo &#123;</span><br><span class="line">        f,err := os.Open(file.Name() + <span class="string">&quot;/&quot;</span> + f.Name())</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        err = Compress(f,prefix,zw)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="将数据直接写入压缩文件"><a href="#将数据直接写入压缩文件" class="headerlink" title="将数据直接写入压缩文件"></a>将数据直接写入压缩文件</h6><p>将格式化数据写入压缩文件让用户下载，只对数据进行压缩不在本地生成文件：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompressedData</span><span class="params">(data *bytes.Buffer,dest <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    zipBuffer := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">    zipWriter := zip.NewWriter(zipBuffer)</span><br><span class="line">    <span class="comment">// Create entry in zip file</span></span><br><span class="line">    zipEntry,err := zipWriter.Create(dest)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// Write content into zip writer</span></span><br><span class="line">    <span class="keyword">if</span> _,err := zipEntry.Write(data.Bytes());err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Make sure to check the error on Close.</span></span><br><span class="line">    <span class="keyword">if</span> err := zipWriter.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="解压缩文件"><a href="#解压缩文件" class="headerlink" title="解压缩文件"></a>解压缩文件</h6><p>DeCompressed负责读取压缩文件并调用deCompressed，将读取的内容写入解压缩后的文件：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeCompressed</span><span class="params">(src <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    s,_ := os.Open(src)</span><br><span class="line">    info,_ := s.Stat()</span><br><span class="line">    ZipReader,err := zip.NewReader(s,info.Size())</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _,f := <span class="keyword">range</span> ZipReader.File &#123;</span><br><span class="line">        <span class="keyword">if</span> err := deCompressed(f); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deCompressed</span><span class="params">(f *zip.File)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    d, _ := os.Create(f.Name)</span><br><span class="line">    unzipFile,err := f.Open()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">if</span> _,err := io.Copy(d.unzipFile); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := unzipFile.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Bufio（实现有缓冲的I-O）"><a href="#Bufio（实现有缓冲的I-O）" class="headerlink" title="Bufio（实现有缓冲的I/O）"></a>Bufio（实现有缓冲的I/O）</h3><p>主要提供一些操作io缓存流的函数和方法，有时为了提高针对流操作的效率，不然不能缺少针对缓冲流的相关操作</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	func ScanBytes(data []byte, atEOF bool) (advance int,token []byte,err error)</span></span><br><span class="line"><span class="comment">	func ScanLines(data []byte, atEOF bool) (advance int,token []byte,err error)</span></span><br><span class="line"><span class="comment">	func ScanRunes(data []byte, atEOF bool) (advance int,token []byte,err error)</span></span><br><span class="line"><span class="comment">	func ScanWords(data []byte, atEOF bool) (advance int,token []byte,err error)</span></span><br><span class="line"><span class="comment">type ReadWriter</span></span><br><span class="line"><span class="comment">	func NewReadWriter(r *Reader,w *Writer) *ReadWriter</span></span><br><span class="line"><span class="comment">type Reader</span></span><br><span class="line"><span class="comment">	func NewReader(rd io.Reader) *Reader</span></span><br><span class="line"><span class="comment">	func NewReaderSize(rd io.Reader,size int) *Reader</span></span><br><span class="line"><span class="comment">	func (b *Reader) Buffered() int</span></span><br><span class="line"><span class="comment">	func (b *Reader) Discard(n int) (discarded int,err error)</span></span><br><span class="line"><span class="comment">	func (b *Reader) Peek(n int) ([]byte,error)</span></span><br><span class="line"><span class="comment">	func (b *Reader) Read(p []byte) (n int, err error)</span></span><br><span class="line"><span class="comment">	func (b *Reader) ReadByte() (byte, error)</span></span><br><span class="line"><span class="comment">	func (b *Reader) ReadBytes(delim byte) ([]byte, error)</span></span><br><span class="line"><span class="comment">	func (b *Reader) ReadLine() (line []byte, isPrefix bool, err error)</span></span><br><span class="line"><span class="comment">	func (b *Reader) ReadRune() (r rune, size int, err error)</span></span><br><span class="line"><span class="comment">	func (b *Reader) ReadSlice(delim byte) (line []byte, err error)</span></span><br><span class="line"><span class="comment">	func (b *Reader) ReadString(delim byte) (string, error)</span></span><br><span class="line"><span class="comment">	func (b *Reader) Reset(r io.Reader)</span></span><br><span class="line"><span class="comment">	func (b *Reader) Size() int</span></span><br><span class="line"><span class="comment">	func (b *Reader) UnreadByte() error</span></span><br><span class="line"><span class="comment">	func (b *Reader) UnreadRune() error</span></span><br><span class="line"><span class="comment">	func (b *Reader) WriteTo(w io.Writer) (n int64, err error)</span></span><br><span class="line"><span class="comment">type Scanner</span></span><br><span class="line"><span class="comment">	func NewScanner(r io.Reader) *Scanner</span></span><br><span class="line"><span class="comment">	func (s *Scanner) Buffer(buf []byte,max int)</span></span><br><span class="line"><span class="comment">	func (s *Scanner) Bytes() []byte</span></span><br><span class="line"><span class="comment">	func (s *Scanner) Err() error</span></span><br><span class="line"><span class="comment">	func (s *Scanner) Scan() bool</span></span><br><span class="line"><span class="comment">	func (s *Scanner) Split(split SplitFunc)</span></span><br><span class="line"><span class="comment">	func (s *Scanner) Text() string</span></span><br><span class="line"><span class="comment">type SplitFunc</span></span><br><span class="line"><span class="comment">type Writer</span></span><br><span class="line"><span class="comment">	func NewWriter(w io.Writer) *Writer</span></span><br><span class="line"><span class="comment">	func NewWriterSize(w io.Writer,size int) *Writer</span></span><br><span class="line"><span class="comment">	func (b *Writer) Available() int</span></span><br><span class="line"><span class="comment">	func (b *Writer) Buffered() int</span></span><br><span class="line"><span class="comment">	func (b *Writer) Flush() error</span></span><br><span class="line"><span class="comment">	func (b *Writer) ReadFrom(r io.Reader) (n int64, err error)</span></span><br><span class="line"><span class="comment">	func (b *Writer) Reset(w io.Writer)</span></span><br><span class="line"><span class="comment">	func (b *Writer) Size() int</span></span><br><span class="line"><span class="comment">	func (b *Writer) Write(p []byte) (nn int, err error)</span></span><br><span class="line"><span class="comment">	func (b *Writer) WriteByte(c byte) error</span></span><br><span class="line"><span class="comment">	func (b *Writer) WriteRune(r rune) (size int, err error)</span></span><br><span class="line"><span class="comment">	func (b *Writer) WriteString(s string) (int, error)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		ScanBytes逐字节读取数据</span></span><br><span class="line"><span class="comment">	*func ScanBytes(data []byte, atEOF bool) (advance int, token []byte, err error)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	s := strings.NewReader(<span class="string">&quot;Hello world&quot;</span>)</span><br><span class="line">	bs := bufio.NewScanner(s)</span><br><span class="line">	bs.Split(bufio.ScanBytes)</span><br><span class="line">	<span class="keyword">for</span> bs.Scan() &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, bs.Text())</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	ScanLines逐行读取数据</span></span><br><span class="line"><span class="comment">	*func ScanLines(data []byte, atEOF bool) (advance int, token []byte, err error)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	s := strings.NewReader(<span class="string">&quot;Hello 世界\nhaha&quot;</span>)</span><br><span class="line">	bs := bufio.NewScanner(s)</span><br><span class="line">	bs.Split(bufio.ScanLines)</span><br><span class="line">	<span class="keyword">for</span> bs.Scan() &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, bs.Text())</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	ScanRunes逐字读取数据</span></span><br><span class="line"><span class="comment">	*func ScanRunes(data []byte,atEOF bool) (advance int,token []byte,err error)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	s := strings.NewReader(<span class="string">&quot;hello 世界&quot;</span>)</span><br><span class="line">	bs := bufio.NewScanner(s)</span><br><span class="line">	bs.Split(bufio.ScanRunes)</span><br><span class="line">	<span class="keyword">for</span> bs.Scan() &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, bs.Text())</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	输出：</span></span><br><span class="line"><span class="comment">    	h</span></span><br><span class="line"><span class="comment">    	e</span></span><br><span class="line"><span class="comment">    	l</span></span><br><span class="line"><span class="comment">    	l</span></span><br><span class="line"><span class="comment">    	o</span></span><br><span class="line"><span class="comment">    	</span></span><br><span class="line"><span class="comment">    	世</span></span><br><span class="line"><span class="comment">    	界</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	ScanWords逐词读取数据</span></span><br><span class="line"><span class="comment">	*func ScanWords(data []byte,atEOF bool) (advance int,token []byte,err error)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	s := strings.NewReader(<span class="string">&quot;hello world! 世界 shijie sh&quot;</span>)</span><br><span class="line">	bs := bufio.NewScanner(s)</span><br><span class="line">	bs.Split(bufio.ScanWords)</span><br><span class="line">	<span class="keyword">for</span> bs.Scan() &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, bs.Text())</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	输出:</span></span><br><span class="line"><span class="comment">    	hello</span></span><br><span class="line"><span class="comment">    	world!</span></span><br><span class="line"><span class="comment">    	世界</span></span><br><span class="line"><span class="comment">    	shijie</span></span><br><span class="line"><span class="comment">    	sh</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">   	<span class="comment">/*</span></span><br><span class="line"><span class="comment">   		NewReadWriter封装r和w为一个bufio。ReadWriter对象既可读也可写</span></span><br><span class="line"><span class="comment">   	*func NewReadWriter(r *Reader,w *Writer) *ReadWriter</span></span><br><span class="line"><span class="comment">   	*/</span></span><br><span class="line">   	b := bytes.NewBuffer(<span class="built_in">make</span>([]<span class="type">byte</span>,<span class="number">0</span>))</span><br><span class="line">   	bw := bufio.NewWriter(b)</span><br><span class="line">   	s := strings.NewReader(<span class="string">&quot;123&quot;</span>)</span><br><span class="line">   	br := bufio.NewReader(s)</span><br><span class="line">   	rw := bufio.NewReadWriter(br,bw)</span><br><span class="line">   	p,_ := rw.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">   	fmt.Printf(<span class="string">&quot;%s\n&quot;</span>,<span class="type">string</span>(p))</span><br><span class="line"></span><br><span class="line">   	rw.WriteString(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">   	rw.Flush()</span><br><span class="line">   	fmt.Println(b)</span><br><span class="line">    </span><br><span class="line">   	<span class="comment">/*</span></span><br><span class="line"><span class="comment">   		NewReader读取数据存放于Reader中</span></span><br><span class="line"><span class="comment">   	*func NewReader(rd io.Reader) *Reader</span></span><br><span class="line"><span class="comment">   	*/</span>	</span><br><span class="line">   	b := bufio.NewReader(os.Stdin)</span><br><span class="line">   	s,_ := b.ReadString(<span class="string">&#x27;\n&#x27;</span>)	<span class="comment">//读取字符直到首次出现回车</span></span><br><span class="line">   	fmt.Println(s)</span><br><span class="line">    </span><br><span class="line">   	<span class="comment">/*</span></span><br><span class="line"><span class="comment">   		Buffered方法返回可从缓冲区中读出数据的字节数</span></span><br><span class="line"><span class="comment">	*func (b *Reader) Buffered() int</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		Peek返回输入流下n个字节且不会移动位置，返回的[]byte只在下一次调用读取操作前合法，若Peek返回的切片长度比n小，它也会返回一个错误说明原因，若n比缓冲尺寸大，返回的错误将是ErrBufferFull</span></span><br><span class="line"><span class="comment">	*func (b *Reader) Peek(n int) ([]byte,error)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	Read从b中读出数据存放到p中，返回读出的字节数和遇到的错误</span></span><br><span class="line"><span class="comment">    	若缓存不为空则只能读出缓存中存在的数据，不会从底层io.Reader读取</span></span><br><span class="line"><span class="comment">    	若缓存为空，则：</span></span><br><span class="line"><span class="comment">    	1、若len(p) &gt;= 缓存大小，直接从底层io.Reader中读出到p中</span></span><br><span class="line"><span class="comment">    	2、若len(p) &lt; 缓存大小，将数据从底层读取到缓存中，再从缓存中读取到p中</span></span><br><span class="line"><span class="comment">    *func (b *Reader) Read(p []byte) (n int,err error)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	Reset方法丢弃所有的缓存数据，重置所有的状态且将缓存读切换到r</span></span><br><span class="line"><span class="comment">    *func (b *Reader) Reset(r io.Reader)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    s := strings.NewReader(<span class="string">&quot;ABCDEF&quot;</span>)</span><br><span class="line">   	str := strings.NewReader(<span class="string">&quot;123456&quot;</span>)</span><br><span class="line">  	br := bufio.NewReader(s)</span><br><span class="line">   	b,_ := br.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">   	fmt.Println(b)</span><br><span class="line">   	br.Reset(str)</span><br><span class="line">   	b,_ = br.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">   	fmt.Println(b)</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	输出：</span></span><br><span class="line"><span class="comment">    	ABCDEF</span></span><br><span class="line"><span class="comment">		123456</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	Size方法返回缓存区的大小（以字节为单位）</span></span><br><span class="line"><span class="comment">    *func (b *Reader) Size() int	</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    s := strings.NewReader(<span class="string">&quot;ABCDEF&quot;</span>)</span><br><span class="line">    b := bufio.NewReader(s)</span><br><span class="line">    n := b.Size()</span><br><span class="line">    fmt.Println(n)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	UnreadByte方法作用是撤销最近一次读出的字节，只要有内容读出就可以使用该方法撤销一个字节</span></span><br><span class="line"><span class="comment">    *func (b *Reader) UnreadByte() error</span></span><br><span class="line"><span class="comment">    	UnreadRune方法的作用是返回最近一次调用的unicode码值，若最近一次读取的不是调用的ReadRune，会返回错误</span></span><br><span class="line"><span class="comment">    *func (b *Reader) UnreadRune() error</span></span><br><span class="line"><span class="comment">    	Err方法返回扫描仪遇到的第一个非EOF错误</span></span><br><span class="line"><span class="comment">    *func (s *Scanner) Err() error</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	Scan方法获取当前位置的token（该token可以通过Bytes或Text方法获取），并让Scanner的扫描位置移动到下一个token，当抵达输入流结尾或遇到错误而停止时返回false,Err方法此时返回nil</span></span><br><span class="line"><span class="comment">    *func (s *Scanner) Scan() bool</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    s := strings.NewReader(<span class="string">&quot;asffgghjhjhjk&quot;</span>)</span><br><span class="line">	scanner := bufio.NewScanner(s)</span><br><span class="line">	flag := scanner.Scan()</span><br><span class="line">	fmt.Println(flag)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	split方法设置该Scanner()的分割函数，本方法必须在Scan之前调用</span></span><br><span class="line"><span class="comment">    *func (s *Scanner) Split(split SplitFunc)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">const</span> input = <span class="string">&quot;1234 5678 1234567901234567&quot;</span></span><br><span class="line">	scanner := bufio.NewScanner(strings.NewReader(input))</span><br><span class="line">	split := <span class="function"><span class="keyword">func</span><span class="params">(data []<span class="type">byte</span>, atEOF <span class="type">bool</span>)</span></span> (advance <span class="type">int</span>, token []<span class="type">byte</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">		advance, token, err = bufio.ScanWords(data, atEOF)</span><br><span class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span> &amp;&amp; token != <span class="literal">nil</span> &#123;</span><br><span class="line">			_, err = strconv.ParseInt(<span class="type">string</span>(token), <span class="number">10</span>, <span class="number">32</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	scanner.Split(split)</span><br><span class="line">	<span class="keyword">for</span> scanner.Scan() &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%s \n&quot;</span>, scanner.Text())</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	输出：</span></span><br><span class="line"><span class="comment">    	1234</span></span><br><span class="line"><span class="comment">    	5678</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	Text方法创建并返回最近一次scan调用生成的token</span></span><br><span class="line"><span class="comment">    *func (s *Scanner) Text() string</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    s := strings.NewReader(<span class="string">&quot;asvgfgghgjh\nsddgffgfg&quot;</span>)</span><br><span class="line">	scanner := bufio.NewScanner(s)</span><br><span class="line">	<span class="keyword">for</span> scanner.Scan() &#123;</span><br><span class="line">		fmt.Println(scanner.Text())</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	输出：</span></span><br><span class="line"><span class="comment">    	asvgfgghgjh</span></span><br><span class="line"><span class="comment">		sddgffgfg</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Builtin（为go提供一些内置的类型和函数）"><a href="#Builtin（为go提供一些内置的类型和函数）" class="headerlink" title="Builtin（为go提供一些内置的类型和函数）"></a>Builtin（为go提供一些内置的类型和函数）</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	func append(slice []Type,elems ...Type) []Type</span></span><br><span class="line"><span class="comment">	func cap(v Type) int</span></span><br><span class="line"><span class="comment">	func close(c chan&lt;- Type)</span></span><br><span class="line"><span class="comment">	func complex(r,i FloatType) ComplexType</span></span><br><span class="line"><span class="comment">	func copy(dst,src []Type) int</span></span><br><span class="line"><span class="comment">	func delete(m map[Type]Type1,key Type)</span></span><br><span class="line"><span class="comment">	func imag(c ComplexType) FloatType</span></span><br><span class="line"><span class="comment">	func len(v Type) int</span></span><br><span class="line"><span class="comment">	func make(t Type,size ...IntegerType) Type</span></span><br><span class="line"><span class="comment">	func new(Type) *Type</span></span><br><span class="line"><span class="comment">	func panic(v interface&#123;&#125;)</span></span><br><span class="line"><span class="comment">	func print(args ...Type)</span></span><br><span class="line"><span class="comment">	func println(args ...Type)</span></span><br><span class="line"><span class="comment">	func real(c ComplexType) FloatType</span></span><br><span class="line"><span class="comment">	func recover() interface&#123;&#125;</span></span><br><span class="line"><span class="comment">	type ComplexType</span></span><br><span class="line"><span class="comment">	type FloatType</span></span><br><span class="line"><span class="comment">	type IntegerType</span></span><br><span class="line"><span class="comment">    type Type</span></span><br><span class="line"><span class="comment">    type Type1</span></span><br><span class="line"><span class="comment">    type bool</span></span><br><span class="line"><span class="comment">    type byte</span></span><br><span class="line"><span class="comment">    type complex128</span></span><br><span class="line"><span class="comment">    type complex64</span></span><br><span class="line"><span class="comment">    type error</span></span><br><span class="line"><span class="comment">    type float32</span></span><br><span class="line"><span class="comment">    type float64</span></span><br><span class="line"><span class="comment">    type int</span></span><br><span class="line"><span class="comment">    type int16</span></span><br><span class="line"><span class="comment">    type int32</span></span><br><span class="line"><span class="comment">    type int64</span></span><br><span class="line"><span class="comment">    type int8</span></span><br><span class="line"><span class="comment">    type rune</span></span><br><span class="line"><span class="comment">    type string</span></span><br><span class="line"><span class="comment">    type uint</span></span><br><span class="line"><span class="comment">    type uint16</span></span><br><span class="line"><span class="comment">    type uint32</span></span><br><span class="line"><span class="comment">    type uint64</span></span><br><span class="line"><span class="comment">    type uint8</span></span><br><span class="line"><span class="comment">    type uintptr</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Bytes（主要提供操作字节切片的函数和方法）"><a href="#Bytes（主要提供操作字节切片的函数和方法）" class="headerlink" title="Bytes（主要提供操作字节切片的函数和方法）"></a>Bytes（主要提供操作字节切片的函数和方法）</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	func Compare(a, b []byte) int</span></span><br><span class="line"><span class="comment">    func Contains(b, subslice []byte) bool</span></span><br><span class="line"><span class="comment">    func ContainsAny(b []byte, chars string) bool</span></span><br><span class="line"><span class="comment">    func ContainsRune(b []byte, r rune) bool</span></span><br><span class="line"><span class="comment">    func Count(s, sep []byte) int</span></span><br><span class="line"><span class="comment">    func Equal(a, b []byte) bool</span></span><br><span class="line"><span class="comment">    func EqualFold(s, t []byte) bool</span></span><br><span class="line"><span class="comment">    func Fields(s []byte) [][]byte</span></span><br><span class="line"><span class="comment">    func FieldsFunc(s []byte, f func(rune) bool) [][]byte</span></span><br><span class="line"><span class="comment">    func HasPrefix(s, prefix []byte) bool</span></span><br><span class="line"><span class="comment">    func HasSuffix(s, suffix []byte) bool</span></span><br><span class="line"><span class="comment">    func Index(s, sep []byte) int</span></span><br><span class="line"><span class="comment">    func IndexAny(s []byte, chars string) int</span></span><br><span class="line"><span class="comment">    func IndexByte(b []byte, c byte) int</span></span><br><span class="line"><span class="comment">    func IndexFunc(s []byte, f func(r rune) bool) int</span></span><br><span class="line"><span class="comment">    func IndexRune(s []byte, r rune) int</span></span><br><span class="line"><span class="comment">    func Join(s [][]byte, sep []byte) []byte</span></span><br><span class="line"><span class="comment">    func LastIndex(s, sep []byte) int</span></span><br><span class="line"><span class="comment">    func LastIndexAny(s []byte, chars string) int</span></span><br><span class="line"><span class="comment">    func LastIndexByte(s []byte, c byte) int</span></span><br><span class="line"><span class="comment">    func LastIndexFunc(s []byte, f func(r rune) bool) int</span></span><br><span class="line"><span class="comment">    func Map(mapping func(r rune) rune, s []byte) []byte</span></span><br><span class="line"><span class="comment">    func Repeat(b []byte, count int) []byte</span></span><br><span class="line"><span class="comment">    func Replace(s, old, new []byte, n int) []byte</span></span><br><span class="line"><span class="comment">    func ReplaceAll(s, old, new []byte) []byte</span></span><br><span class="line"><span class="comment">    func Runes(s []byte) []rune</span></span><br><span class="line"><span class="comment">    func Split(s, sep []byte) [][]byte</span></span><br><span class="line"><span class="comment">    func SplitAfter(s, sep []byte) [][]byte</span></span><br><span class="line"><span class="comment">    func SplitAfterN(s, sep []byte, n int) [][]byte</span></span><br><span class="line"><span class="comment">    func SplitN(s, sep []byte, n int) [][]byte</span></span><br><span class="line"><span class="comment">    func Title(s []byte) []byte</span></span><br><span class="line"><span class="comment">    func ToLower(s []byte) []byte</span></span><br><span class="line"><span class="comment">    func ToLowerSpecial(c unicode.SpecialCase, s []byte) []byte</span></span><br><span class="line"><span class="comment">    func ToTitle(s []byte) []byte</span></span><br><span class="line"><span class="comment">    func ToTitleSpecial(c unicode.SpecialCase, s []byte) []byte</span></span><br><span class="line"><span class="comment">    func ToUpper(s []byte) []byte</span></span><br><span class="line"><span class="comment">    func ToUpperSpecial(c unicode.SpecialCase, s []byte) []byte</span></span><br><span class="line"><span class="comment">    func ToValidUTF8(s, replacement []byte) []byte</span></span><br><span class="line"><span class="comment">    func Trim(s []byte, cutset string) []byte</span></span><br><span class="line"><span class="comment">    func TrimFunc(s []byte, f func(r rune) bool) []byte</span></span><br><span class="line"><span class="comment">    func TrimLeft(s []byte, cutset string) []byte</span></span><br><span class="line"><span class="comment">    func TrimLeftFunc(s []byte, f func(r rune) bool) []byte</span></span><br><span class="line"><span class="comment">    func TrimPrefix(s, prefix []byte) []byte</span></span><br><span class="line"><span class="comment">    func TrimRight(s []byte, cutset string) []byte</span></span><br><span class="line"><span class="comment">    func TrimRightFunc(s []byte, f func(r rune) bool) []byte</span></span><br><span class="line"><span class="comment">    func TrimSpace(s []byte) []byte</span></span><br><span class="line"><span class="comment">    func TrimSuffix(s, suffix []byte) []byte</span></span><br><span class="line"><span class="comment">type Buffer</span></span><br><span class="line"><span class="comment">    func NewBuffer(buf []byte) *Buffer</span></span><br><span class="line"><span class="comment">    func NewBufferString(s string) *Buffer</span></span><br><span class="line"><span class="comment">    func (b *Buffer) Bytes() []byte</span></span><br><span class="line"><span class="comment">    func (b *Buffer) Cap() int</span></span><br><span class="line"><span class="comment">    func (b *Buffer) Grow(n int)</span></span><br><span class="line"><span class="comment">    func (b *Buffer) Len() int</span></span><br><span class="line"><span class="comment">    func (b *Buffer) Next(n int) []byte</span></span><br><span class="line"><span class="comment">    func (b *Buffer) Read(p []byte) (n int, err error)</span></span><br><span class="line"><span class="comment">    func (b *Buffer) ReadByte() (byte, error)</span></span><br><span class="line"><span class="comment">    func (b *Buffer) ReadBytes(delim byte) (line []byte, err error)</span></span><br><span class="line"><span class="comment">    func (b *Buffer) ReadFrom(r io.Reader) (n int64, err error)</span></span><br><span class="line"><span class="comment">    func (b *Buffer) ReadRune() (r rune, size int, err error)</span></span><br><span class="line"><span class="comment">    func (b *Buffer) ReadString(delim byte) (line string, err error)</span></span><br><span class="line"><span class="comment">    func (b *Buffer) Reset()</span></span><br><span class="line"><span class="comment">    func (b *Buffer) String() string</span></span><br><span class="line"><span class="comment">    func (b *Buffer) Truncate(n int)</span></span><br><span class="line"><span class="comment">    func (b *Buffer) UnreadByte() error</span></span><br><span class="line"><span class="comment">    func (b *Buffer) UnreadRune() error</span></span><br><span class="line"><span class="comment">    func (b *Buffer) Write(p []byte) (n int, err error)</span></span><br><span class="line"><span class="comment">    func (b *Buffer) WriteByte(c byte) error</span></span><br><span class="line"><span class="comment">    func (b *Buffer) WriteRune(r rune) (n int, err error)</span></span><br><span class="line"><span class="comment">    func (b *Buffer) WriteString(s string) (n int, err error)</span></span><br><span class="line"><span class="comment">    func (b *Buffer) WriteTo(w io.Writer) (n int64, err error)</span></span><br><span class="line"><span class="comment">type Reader</span></span><br><span class="line"><span class="comment">    func NewReader(b []byte) *Reader</span></span><br><span class="line"><span class="comment">    func (r *Reader) Len() int</span></span><br><span class="line"><span class="comment">    func (r *Reader) Read(b []byte) (n int, err error)</span></span><br><span class="line"><span class="comment">    func (r *Reader) ReadAt(b []byte, off int64) (n int, err error)</span></span><br><span class="line"><span class="comment">    func (r *Reader) ReadByte() (byte, error)</span></span><br><span class="line"><span class="comment">    func (r *Reader) ReadRune() (ch rune, size int, err error)</span></span><br><span class="line"><span class="comment">    func (r *Reader) Reset(b []byte)</span></span><br><span class="line"><span class="comment">    func (r *Reader) Seek(offset int64, whence int) (int64, error)</span></span><br><span class="line"><span class="comment">    func (r *Reader) Size() int64</span></span><br><span class="line"><span class="comment">    func (r *Reader) UnreadByte() error</span></span><br><span class="line"><span class="comment">    func (r *Reader) UnreadRune() error</span></span><br><span class="line"><span class="comment">    func (r *Reader) WriteTo(w io.Writer) (n int64, err error)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	Compare返回一个整数表示两个[]byte切片按字典比较的结果，若a==b返回0；若a&lt;b返回-1；若a&gt;b返回1。nil参数视为空切片</span></span><br><span class="line"><span class="comment">    *func Compare(a,b []byte) int</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	Contains判断切片b是否包含子切片subslice</span></span><br><span class="line"><span class="comment">    *func Contains(b,subslice []byte) bool&#123;</span></span><br><span class="line"><span class="comment">    	return Index(b,subslice) != -1</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	Count计算s中有多少个不重叠的sep子切片</span></span><br><span class="line"><span class="comment">    *func Count(s,sep []byte) int&#123;</span></span><br><span class="line"><span class="comment">    	if len(sep) == 0 &#123;</span></span><br><span class="line"><span class="comment">    		return utf8.RuneCount(s) + 1</span></span><br><span class="line"><span class="comment">    	&#125;</span></span><br><span class="line"><span class="comment">    	if len(sep) == 1 &#123;</span></span><br><span class="line"><span class="comment">    		return bytealg.Count(s,sep[0])</span></span><br><span class="line"><span class="comment">    	&#125;</span></span><br><span class="line"><span class="comment">    	n := 0</span></span><br><span class="line"><span class="comment">    	for &#123;</span></span><br><span class="line"><span class="comment">    		i := Index(s,sep)</span></span><br><span class="line"><span class="comment">    		if i == -1 &#123;</span></span><br><span class="line"><span class="comment">    			return n</span></span><br><span class="line"><span class="comment">    		&#125;</span></span><br><span class="line"><span class="comment">    		n++</span></span><br><span class="line"><span class="comment">    		s = s[i+len(sep):]</span></span><br><span class="line"><span class="comment">    	&#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	判断a和b是否长度相同且包含相同字节。nil参数等效于空片</span></span><br><span class="line"><span class="comment">    *func Equal(a,b []byte) bool &#123;</span></span><br><span class="line"><span class="comment">    	return string(a) == string(b)</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	EqualFold判断两个utf-8编码切片（将unicode大写、小写、标题三种格式字符视为相同）是否相同</span></span><br><span class="line"><span class="comment">    *func EqualFold(s,t []byte) bool</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	Fields返回将字符串按照空白字符分割的多个子切片，若字符串全是空白或是空字符串的话，会返回空切片</span></span><br><span class="line"><span class="comment">    *func Fields(s []byte) [][]byte</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;Fields are: %q&quot;</span>,bytes.Fields([]bye(<span class="string">&quot;  foo bar  baz   &quot;</span>)))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	FieldsFunc使用函数f确定分割符（满足f的utf-8码值），若字符串全部是分隔符或是空字符串的话，会返回空切片</span></span><br><span class="line"><span class="comment">    *func FieldsFunc(s []byte,f func(rune) bool) [][]byte</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    f := <span class="function"><span class="keyword">func</span><span class="params">(c <span class="type">rune</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !unicode.IsLetter(c) &amp;&amp; !unicode.IsNumber(c)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Fields are: %q&quot;</span>,bytes.FieldsFunc([]<span class="type">byte</span>(<span class="string">&quot;  foo1;bar2,baz3...&quot;</span>),f))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	HasPrefix测试字节片s是否以前缀开头，HasSuffix测试字节片s是否以后缀结尾</span></span><br><span class="line"><span class="comment">    *func HasPrefix(s,prefix []byte) bool &#123;</span></span><br><span class="line"><span class="comment">    	return len(s) &gt;= len(prefix) &amp;&amp; Equal(s[0:len(prefix)],prefix)</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    *func HasSuffix(s,suffix []byte) bool &#123;</span></span><br><span class="line"><span class="comment">    	return len(s) &gt;= len(suffix) &amp;&amp; Equal(s[len(s)-len(suffix):],suffix)</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	Index返回s中sep的第一个实例的索引；若s中不存在sep，则返回-1</span></span><br><span class="line"><span class="comment">    *func Index(s,sep []byte) int</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	Join将s的元素连接起来创建一个新的字节片，分隔符sep放置在所得切片中的元素之间</span></span><br><span class="line"><span class="comment">    *func Join(s [][]byte,sep []byte) []byte &#123;</span></span><br><span class="line"><span class="comment">    	//若s无元素则返回空字节片</span></span><br><span class="line"><span class="comment">    	if len(s) == 0 &#123;return []byte&#123;&#125;&#125;	</span></span><br><span class="line"><span class="comment">    	if len(s) == 1 &#123;return append([]byte(nil),s[0]...)&#125;</span></span><br><span class="line"><span class="comment">    	n := len(sep) * (len(s) - 1)</span></span><br><span class="line"><span class="comment">    	//计算所有元素和分隔符的字节总数</span></span><br><span class="line"><span class="comment">    	for _,v := range s &#123;</span></span><br><span class="line"><span class="comment">    		n += len(v)</span></span><br><span class="line"><span class="comment">    	&#125;</span></span><br><span class="line"><span class="comment">    	b := make([]byte,n)</span></span><br><span class="line"><span class="comment">    	bp := copy(n,s[0])	//记录连接位置</span></span><br><span class="line"><span class="comment">    	for _,v := range s[1:] &#123;</span></span><br><span class="line"><span class="comment">    		bp += copy(b[bp:],sep)</span></span><br><span class="line"><span class="comment">    		bp += copy(b[bp:],v)</span></span><br><span class="line"><span class="comment">    	&#125;</span></span><br><span class="line"><span class="comment">    	return b</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    s := [][]<span class="type">byte</span>&#123;[]<span class="type">byte</span>(<span class="string">&quot;foo&quot;</span>), []<span class="type">byte</span>(<span class="string">&quot;bar&quot;</span>), []<span class="type">byte</span>(<span class="string">&quot;baz&quot;</span>)&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s&quot;</span>, bytes.Join(s, []<span class="type">byte</span>(<span class="string">&quot;,&quot;</span>)))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	LastIndex返回s中sep最后一个实例的索引：若s中不存在sep，则返回-1</span></span><br><span class="line"><span class="comment">    *func LastIndex(s,sep []byte) int</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    fmt.Println(bytes.Index([]<span class="type">byte</span>(<span class="string">&quot;go gopher&quot;</span>), []<span class="type">byte</span>(<span class="string">&quot;go&quot;</span>)))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	LastIndexByte返回s中c的最后一个实例的索引；若s中不存在c则返回-1</span></span><br><span class="line"><span class="comment">    *func LastIndexByte(s []byte,c byte) int &#123;</span></span><br><span class="line"><span class="comment">    	for i := len(s) - 1; i &gt;= 0; i-- &#123;</span></span><br><span class="line"><span class="comment">    		if s[i] == c &#123;</span></span><br><span class="line"><span class="comment">    			return i</span></span><br><span class="line"><span class="comment">    		&#125;</span></span><br><span class="line"><span class="comment">    	&#125;</span></span><br><span class="line"><span class="comment">    	return -1</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    fmt.Println(bytes.LastIndexByte([]<span class="type">byte</span>(<span class="string">&quot;go gopher&quot;</span>), <span class="type">byte</span>(<span class="string">&#x27;g&#x27;</span>)))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	返回count个b串联形成的新的切片</span></span><br><span class="line"><span class="comment">    *func Repeat(b []byte,count int) &#123;</span></span><br><span class="line"><span class="comment">    	if count == 0 &#123;return []byte&#123;&#125;&#125;</span></span><br><span class="line"><span class="comment">    	if count &lt; 0 &#123;</span></span><br><span class="line"><span class="comment">    		panic(&quot;bytes: negative Repeat count&quot;)</span></span><br><span class="line"><span class="comment">    	&#125;else if len(b)*count/count != len(b) &#123;</span></span><br><span class="line"><span class="comment">    		panic(&quot;bytes: Repeat count causes overflow&quot;)</span></span><br><span class="line"><span class="comment">    	&#125;</span></span><br><span class="line"><span class="comment">    	</span></span><br><span class="line"><span class="comment">    	nb := make([]byte,len(b)*count)</span></span><br><span class="line"><span class="comment">    	bp := copy(nb,b)</span></span><br><span class="line"><span class="comment">    	for bp &lt; len(nb) &#123;</span></span><br><span class="line"><span class="comment">    		copy(nb[bp:],nb[:bp])</span></span><br><span class="line"><span class="comment">    		bp *= 2</span></span><br><span class="line"><span class="comment">    	&#125;</span></span><br><span class="line"><span class="comment">    	return nb</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;ba%s&quot;</span>, bytes.Repeat([]<span class="type">byte</span>(<span class="string">&quot;na&quot;</span>), <span class="number">2</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	Replace将返回slice的副本，其中有old的前n个非重叠实例被new取代，若old为空，则它在切片的开头和每个UTF-8序列之后匹配，最多产生k + 1个k - rune切片的替换；若n &lt; 0，则替换次数没有限制</span></span><br><span class="line"><span class="comment">    	func Replace(s,old,new []byte,n int) []byte &#123;</span></span><br><span class="line"><span class="comment">    		m := 0</span></span><br><span class="line"><span class="comment">    		if n != 0 &#123;</span></span><br><span class="line"><span class="comment">    			//计算s切片中有多少个old</span></span><br><span class="line"><span class="comment">    			m = Count(s,old)</span></span><br><span class="line"><span class="comment">    		&#125;</span></span><br><span class="line"><span class="comment">    		if m == 0 &#123;</span></span><br><span class="line"><span class="comment">    			// Just return a copy</span></span><br><span class="line"><span class="comment">    			return append([]byte(nil),s...)</span></span><br><span class="line"><span class="comment">    		&#125;</span></span><br><span class="line"><span class="comment">    		//若要替换的数小于0或大于m则全替换</span></span><br><span class="line"><span class="comment">    		if n &lt; 0 || m &lt; n &#123;</span></span><br><span class="line"><span class="comment">    			n = m</span></span><br><span class="line"><span class="comment">    		&#125;</span></span><br><span class="line"><span class="comment">            //计算缓冲区新切片总数</span></span><br><span class="line"><span class="comment">            t := make([]byte,len(s)+n*(len(new)-len(old)))</span></span><br><span class="line"><span class="comment">            w := 0</span></span><br><span class="line"><span class="comment">            start := 0</span></span><br><span class="line"><span class="comment">            for i := 0; i &lt; n; i++ &#123;</span></span><br><span class="line"><span class="comment">            	j := start</span></span><br><span class="line"><span class="comment">            	if len(old) == 0 &#123;</span></span><br><span class="line"><span class="comment">            		if i &gt; 0 &#123;</span></span><br><span class="line"><span class="comment">            			_,wid := utf8.DecodeRune(s[start:])</span></span><br><span class="line"><span class="comment">            			j += wid</span></span><br><span class="line"><span class="comment">            		&#125;</span></span><br><span class="line"><span class="comment">            	&#125; else &#123;</span></span><br><span class="line"><span class="comment">            		j += Index(s[start:],old)</span></span><br><span class="line"><span class="comment">            	&#125;</span></span><br><span class="line"><span class="comment">            	w += copy(t[w:],s[start:j])</span></span><br><span class="line"><span class="comment">            	w += copy(t[w:],new)</span></span><br><span class="line"><span class="comment">            	start = j + len(old)</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            w += copy(t[w:],s[start:])</span></span><br><span class="line"><span class="comment">            return t[0:w]</span></span><br><span class="line"><span class="comment">    	&#125;</span></span><br><span class="line"><span class="comment">    	</span></span><br><span class="line"><span class="comment">    	func ReplaceAll(s, old, new []byte) []byte &#123;</span></span><br><span class="line"><span class="comment">    		return Replace(s,old,new,-1)</span></span><br><span class="line"><span class="comment">    	&#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, bytes.Replace([]<span class="type">byte</span>(<span class="string">&quot;oink oink oink&quot;</span>), []<span class="type">byte</span>(<span class="string">&quot;k&quot;</span>), []<span class="type">byte</span>(<span class="string">&quot;ky&quot;</span>), <span class="number">2</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	符文将s解释为UTF-8编码的代码点序列。它返回与s等效的一片符文(Unicode代码点)</span></span><br><span class="line"><span class="comment">    	func Runes(s []byte) []rune &#123;</span></span><br><span class="line"><span class="comment">    		t := make([]rune,utf8.RuneCount(s))</span></span><br><span class="line"><span class="comment">    		i := 0</span></span><br><span class="line"><span class="comment">    		for len(s) &gt; 0 &#123;</span></span><br><span class="line"><span class="comment">    			r,l := utf8.DecodeRune(s)</span></span><br><span class="line"><span class="comment">    			t[i] = r</span></span><br><span class="line"><span class="comment">    			i++</span></span><br><span class="line"><span class="comment">    			s = s[l:]</span></span><br><span class="line"><span class="comment">    		&#125; </span></span><br><span class="line"><span class="comment">    		return t</span></span><br><span class="line"><span class="comment">    	&#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    rs := bytes.Runes([]<span class="type">byte</span>(<span class="string">&quot;go gopher&quot;</span>))</span><br><span class="line">    <span class="keyword">for</span> _,r := <span class="keyword">range</span> rs &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%#U\n&quot;</span>,r)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	输出：</span></span><br><span class="line"><span class="comment">    	U+0067 &#x27;g&#x27;</span></span><br><span class="line"><span class="comment">        U+006F &#x27;o&#x27;</span></span><br><span class="line"><span class="comment">        U+0020 &#x27; &#x27;</span></span><br><span class="line"><span class="comment">        U+0067 &#x27;g&#x27;</span></span><br><span class="line"><span class="comment">        U+006F &#x27;o&#x27;</span></span><br><span class="line"><span class="comment">        U+0070 &#x27;p&#x27;</span></span><br><span class="line"><span class="comment">        U+0068 &#x27;h&#x27;</span></span><br><span class="line"><span class="comment">        U+0065 &#x27;e&#x27;</span></span><br><span class="line"><span class="comment">        U+0072 &#x27;r&#x27;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	将片段s分割为所有由sep分隔的子片段，返回这些分隔符之间的子片段的片段，若sep为空，则Split在每个UTF-8序列后拆分，它等效于SplitN，计数为-1</span></span><br><span class="line"><span class="comment">    	func Split(s,sep []byte) [][]byte</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, bytes.Split([]<span class="type">byte</span>(<span class="string">&quot;a,b,c&quot;</span>), []<span class="type">byte</span>(<span class="string">&quot;,&quot;</span>)))</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	输出：[&quot;a&quot; &quot;b&quot; &quot;c&quot;]</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	Trim通过切掉cutset中包含的所有前导和尾随UTF-8编码的代码点返回s的子片段</span></span><br><span class="line"><span class="comment">    	func Trim(s []byte,cutset string) []byte</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;[%q]&quot;</span>, bytes.Trim([]<span class="type">byte</span>(<span class="string">&quot; !!! Achtung! Achtung! !!! &quot;</span>), <span class="string">&quot;! &quot;</span>))</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	输出：[&quot;Achtung! Achtung&quot;]</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><h4 id="Goroutine"><a href="#Goroutine" class="headerlink" title="Goroutine"></a>Goroutine</h4><p>轻量级的执行线程，多个goroutine比一个线程轻量，是go的基本执行单元；每个go程序至少有一个主goroutine（程序启动时自动创建）；使用方法类似其它语言的协程（coroutine）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Hello</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;hello everybody&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> Hello()</span><br><span class="line">    fmt.Println(<span class="string">&quot;Golang-Gorontine Example&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时并未执行Hello方法，main执行完后直接退出了，需要使用通道让Hello-Goroutine告诉main执行完成后退出</span></span><br></pre></td></tr></table></figure>

<h4 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h4><p>多个goroutine之间的沟通渠道，用于将结果、错误或任何信息从一个传递到另一个；通道是有类型的</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Hello</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">int</span>)</span></span>  &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;hello everybody&quot;</span>)</span><br><span class="line">    ch &lt;- <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> Hello(ch)</span><br><span class="line">    &lt;-ch</span><br><span class="line">    fmt.Println(<span class="string">&quot;Golang-Gorontine Example&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当请求进来时，Handler创建一个监控goroutine并打印信息：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/&quot;</span>, SayHello) <span class="comment">// 设置访问的路由</span></span><br><span class="line">    log.Fatalln(http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>,<span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SayHello</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span>  &#123;</span><br><span class="line">    fmt.Println(&amp;request)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="keyword">range</span> time.Tick(time.Second) &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;Current request is in progress&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">    writer.Write([]<span class="type">byte</span>(<span class="string">&quot;Hi, New Request Comes&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时假定请求耗时2s，在请求2s后返回，期望打印2次后立即停止，但运行发现，监控goroutine打印2次后仍不会结束且会一直打印；问题在创建监控goroutine后未对生命周期作控制；下面在打印前检测<code>request.Context()</code>是否已经结束，若结束则退出循环</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/&quot;</span>, SayHello) <span class="comment">// 设置访问的路由</span></span><br><span class="line"></span><br><span class="line">    log.Fatalln(http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>,<span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SayHello</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span>  &#123;</span><br><span class="line">    fmt.Println(&amp;request)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="keyword">range</span> time.Tick(time.Second) &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> &lt;- request.Context().Done():</span><br><span class="line">                fmt.Println(<span class="string">&quot;request is outgoing&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                fmt.Println(<span class="string">&quot;Current request is in progress&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">    writer.Write([]<span class="type">byte</span>(<span class="string">&quot;Hi, New Request Comes&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基于如上需求，context包应运而生；<strong>context可以提供一个请求，从API请求边界到各goroutine请求域数据传递、取消信号及截止时间等能力</strong></p>
<h4 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h4><p>Go中每一个请求都是通过一个单独的Goroutine进行处理的，HTTP/RPC请求处理器往往会启动新的Goroutine访问数据库和RPC服务，可能会创建多个来处理一次请求；Context的主要作用即在不同Goroutine间同步请求特定的数据、取消信号以及处理请求的截止日期</p>
<h4 id="Context接口"><a href="#Context接口" class="headerlink" title="Context接口"></a>Context接口</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">    Deadline() (deadline time.Time, ok <span class="type">bool</span>)</span><br><span class="line">    Done() &lt;- <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    Err() <span class="type">error</span></span><br><span class="line">    Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Deadline方法需要返回当前Context被取消的时间，即完成工作的截止时间</span></span><br><span class="line"><span class="comment">// Done方法返回一个Channel，该Channel会在当前工作完成或上下文被取消后关闭，多次调用该方法会返回同一个Channel</span></span><br><span class="line"><span class="comment">// Err方法返回Context结束的原因，只会在Done返回的Channel被关闭时才会返回非空的值</span></span><br><span class="line">	<span class="comment">// 若当前Context被取消就会返回Canceled错误</span></span><br><span class="line">	<span class="comment">// 若当前Context超时就会返回DeadlineExceed错误</span></span><br><span class="line"><span class="comment">// Value方法从Context中返回键对应的值对于同一个上下文来说，多次调用Value 并传入相同的Key会返回相同的结果，该方法仅用于传递跨API和进程间跟请求域数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 跨域：若a页面想获取b页面资源，但它们的协议、域名、端口、子域名不同；则所进行的访问行动都是跨域的（跨域限制访问其实是浏览器的限制）</span></span><br><span class="line"><span class="comment">// 跨域问题解决：用nginx作为代理服务器只在80端口交互</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Go内置两个函数：Background()和TODO()，这两个函数分别返回一个实现了Context接口的background和todo;</span></span><br><span class="line"><span class="comment">// Background()主要用于main函数、初始化以及测试代码中，作为Context这个树结构的最顶层的Context，也就是根Context</span></span><br><span class="line"><span class="comment">// TODO()，它目前还不知道具体的使用场景，如果我们不知道该使用什么Context的时候，可以使用这个</span></span><br><span class="line"><span class="comment">// background和todo本质上都是emptyCtx结构体类型，是一个不可取消，没有设置截止时间，没有携带任何值的Context</span></span><br></pre></td></tr></table></figure>

<h5 id="With系列函数"><a href="#With系列函数" class="headerlink" title="With系列函数"></a>With系列函数</h5><p>此外，<code>context</code>包中还定义了四个With系列函数；这些函数返回的都是实现了上述接口方法的对应结构体</p>
<p><img src="https://s1.ax1x.com/2023/02/15/pS7P1MD.png"></p>
<h6 id="WithCancel"><a href="#WithCancel" class="headerlink" title="WithCancel"></a>WithCancel</h6><p>接受一个Context并返回其子Context和取消函数cancel</p>
<p>新创建协程中传入子Context做参数且监控其Done通道，若收到消息则退出</p>
<p>需要新协程结束时在外调用cancel函数，即会往子Context的Done通道发送消息</p>
<p>当父Context的Done()关闭时，子ctx的Done()也会被关闭</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 利用根context创建一个父context，并使用其创建一个协程</span></span><br><span class="line"><span class="comment">// 再由父创建一个子context，再使用该子context创建一个协程</span></span><br><span class="line"><span class="comment">// 一段时间后调用父context的cancel函数发现父和子协程都收到信号结束了</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 父context(利用根context得到)</span></span><br><span class="line">	ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 父context的子协程</span></span><br><span class="line">	<span class="keyword">go</span> watch1(ctx)</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 子context，注意：这里虽然也返回了cancel的函数对象，但是未使用</span></span><br><span class="line">	valueCtx, _ := context.WithCancel(ctx)</span><br><span class="line">	<span class="comment">// 子context的子协程</span></span><br><span class="line">	<span class="keyword">go</span> watch2(valueCtx)</span><br><span class="line"> </span><br><span class="line">	fmt.Println(<span class="string">&quot;现在开始等待3秒,time=&quot;</span>, time.Now().Unix())</span><br><span class="line">	time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 调用cancel()</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;等待3秒结束,调用cancel()函数&quot;</span>)</span><br><span class="line">	cancel()</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 再等待5秒看输出，可以发现父context的子协程和子context的子协程都会被结束掉</span></span><br><span class="line">	time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;最终结束,time=&quot;</span>, time.Now().Unix())</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 父context的协程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">watch1</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ctx.Done(): <span class="comment">//取出值即说明是结束信号</span></span><br><span class="line">			fmt.Println(<span class="string">&quot;收到信号，父context的协程退出,time=&quot;</span>, time.Now().Unix())</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			fmt.Println(<span class="string">&quot;父context的协程监控中,time=&quot;</span>, time.Now().Unix())</span><br><span class="line">			time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 子context的协程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">watch2</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ctx.Done(): <span class="comment">//取出值即说明是结束信号</span></span><br><span class="line">			fmt.Println(<span class="string">&quot;收到信号，子context的协程退出,time=&quot;</span>, time.Now().Unix())</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			fmt.Println(<span class="string">&quot;子context的协程监控中,time=&quot;</span>, time.Now().Unix())</span><br><span class="line">			time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// withCancel的实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span></span> (ctx Context, cancel CancelFunc) &#123;</span><br><span class="line">	<span class="keyword">if</span> parent == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;cannot create context from nil parent&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	c := newCancelCtx(parent)   <span class="comment">//返回一个cancelCtx结构体</span></span><br><span class="line">	propagateCancel(parent, &amp;c)   <span class="comment">//绑定父子context关系</span></span><br><span class="line">	<span class="keyword">return</span> &amp;c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> cancelCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">	Context   						<span class="comment">// 自己的父context</span></span><br><span class="line"></span><br><span class="line">	mu       sync.Mutex				</span><br><span class="line">	done     <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;         <span class="comment">// 接收取消信号的管道</span></span><br><span class="line">	children <span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125; <span class="comment">// 包含自己路径下所有子context集合</span></span><br><span class="line">	err      <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ctx.Done()其实就是一个管道，即上面cancelCtx结构体中的done</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; &#123;</span><br><span class="line">	c.mu.Lock()</span><br><span class="line">	<span class="keyword">if</span> c.done == <span class="literal">nil</span> &#123;</span><br><span class="line">		c.done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	d := c.done</span><br><span class="line">	c.mu.Unlock()</span><br><span class="line">	<span class="keyword">return</span> d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="WithTimeout、WithDeadline"><a href="#WithTimeout、WithDeadline" class="headerlink" title="WithTimeout、WithDeadline"></a>WithTimeout、WithDeadline</h6><p><code>WithTimeout</code>底层实现是调用的<code>WithDeadline</code>，并添加对应的过期时间</p>
<p><code>WithDeadline</code>即添加了<code>timer</code>计时器，<code>time.AfterFunc</code>中计时条件满足时自动触发<code>cancel</code>函数</p>
<h6 id="WithValue"><a href="#WithValue" class="headerlink" title="WithValue"></a>WithValue</h6><p>返回一个带有键值对的<code>valueCtx</code>结构体：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> valueCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">	Context</span><br><span class="line">	key, val <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Database"><a href="#Database" class="headerlink" title="Database"></a>Database</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> DB <span class="keyword">struct</span>&#123;&#125;	<span class="comment">//数据库操作句柄，代表一个具有零到多个底层连接的连接池，可以安全的被多个go程同时使用；sql包会自动创建和释放连接，也会维护一个闲置连接的连接池；连接池的大小可用SetMaxldleConns方法控制</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(driverName,dataSourceName <span class="type">string</span>)</span></span> (*DB,<span class="type">error</span>)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	driverName表示driver名称，dataSourceName表示连接数据库的信息；</span></span><br><span class="line"><span class="comment">	Open函数只验证其参数，不创建与数据库的连接，若要检查数据源的名称是否合法，应调用返回值的Ping方法；Open函数只需调用一次，很少需要关闭DB</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> Ping() <span class="type">error</span>		</span><br><span class="line"><span class="comment">// 检查与数据库的连接是否有效</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> Close() <span class="type">error</span>		</span><br><span class="line"><span class="comment">// 关闭数据库，释放任何打开的资源，一般不关闭DB，DB句柄通常被多个go程共享，并长期活跃</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> Exec(query <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) (Result,<span class="type">error</span>)</span><br><span class="line"><span class="comment">// Exec执行一次命令（包括查询、删除、更新、插入等），不返回任何执行结果</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*DB)</span></span> Query(query <span class="type">string</span>,args ...<span class="keyword">interface</span>&#123;&#125;) (*Rows,<span class="type">error</span>)</span><br><span class="line"><span class="comment">// Query执行一次查询，返回多行结果，一般用于执行select命令</span></span><br><span class="line">    age := <span class="number">27</span></span><br><span class="line">    rows, err := db.Query(<span class="string">&quot;SELECT name FROM users WHERE age=?&quot;</span>, age)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> rows.Close()</span><br><span class="line">    <span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">        <span class="keyword">var</span> name <span class="type">string</span></span><br><span class="line">        <span class="keyword">if</span> err := rows.Scan(&amp;name); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Fatal(err)</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%s is %d\n&quot;</span>, name, age)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := rows.Err(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> QueryRow(query <span class="type">string</span>,args ...<span class="keyword">interface</span>&#123;&#125;) *Row</span><br><span class="line"><span class="comment">// QueryRow执行一次查询并期望返回最多一行结果；QueryRow总是返回非nil的值，直到返回值的Scan方法被调用时才会返回被延迟的错误</span></span><br><span class="line">    id := <span class="number">123</span></span><br><span class="line">    <span class="keyword">var</span> username <span class="type">string</span></span><br><span class="line">    err := db.QueryRow(<span class="string">&quot;SELECT username FROM users WHERE id=?&quot;</span>, id).Scan(&amp;username)</span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> err == sql.ErrNoRows:</span><br><span class="line">        log.Printf(<span class="string">&quot;No user with that ID.&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> err != <span class="literal">nil</span>:</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Username is %s\n&quot;</span>, username)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*DB)</span></span> Begin() (*Tx,<span class="type">error</span>)</span><br><span class="line"><span class="comment">// 开始一个事务</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rs *Rows)</span></span> Next() <span class="type">bool</span></span><br><span class="line"><span class="comment">// 用于Scan方法的下一行结果，若成功返回真，若没有下一行或出现错误返回假</span></span><br></pre></td></tr></table></figure>

<h3 id="encoding"><a href="#encoding" class="headerlink" title="encoding"></a>encoding</h3><h4 id="json"><a href="#json" class="headerlink" title="json"></a>json</h4><p><code>struct tag</code>可以决定<code>Marshal</code>和<code>Unmarshal</code>函数如何序列化和反序列化数据</p>
<h5 id="Marshal"><a href="#Marshal" class="headerlink" title="Marshal"></a>Marshal</h5><p><code>func Marshal(v interface&#123;&#125;) ([]byte, error)</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ColorGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID     <span class="type">int</span></span><br><span class="line">    Name   <span class="type">string</span></span><br><span class="line">    Colors []<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line">group := ColorGroup&#123;</span><br><span class="line">    ID:     <span class="number">1</span>,</span><br><span class="line">    Name:   <span class="string">&quot;Reds&quot;</span>,</span><br><span class="line">    Colors: []<span class="type">string</span>&#123;<span class="string">&quot;Crimson&quot;</span>, <span class="string">&quot;Red&quot;</span>, <span class="string">&quot;Ruby&quot;</span>, <span class="string">&quot;Maroon&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">b, err := json.Marshal(group)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;error:&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">os.Stdout.Write(b)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output: &#123;&quot;ID&quot;:1,&quot;Name&quot;:&quot;Reds&quot;,&quot;Colors&quot;:[&quot;Crimson&quot;,&quot;Red&quot;,&quot;Ruby&quot;,&quot;Maroon&quot;]&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="Unmarshal"><a href="#Unmarshal" class="headerlink" title="Unmarshal"></a>Unmarshal</h5><p><code>func Unmarshal(data []byte, v interface&#123;&#125;) error</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonBlob = []<span class="type">byte</span>(<span class="string">`[</span></span><br><span class="line"><span class="string">	&#123;&quot;Name&quot;: &quot;Platypus&quot;, &quot;Order&quot;: &quot;Monotremata&quot;&#125;,</span></span><br><span class="line"><span class="string">	&#123;&quot;Name&quot;: &quot;Quoll&quot;,    &quot;Order&quot;: &quot;Dasyuromorphia&quot;&#125;</span></span><br><span class="line"><span class="string">]`</span>)</span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name  <span class="type">string</span></span><br><span class="line">    Order <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> animals []Animal</span><br><span class="line">err := json.Unmarshal(jsonBlob, &amp;animals)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;error:&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%+v&quot;</span>, animals)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output: [&#123;Name:Platypus Order:Monotremata&#125; &#123;Name:Quoll Order:Dasyuromorphia&#125;]</span></span><br></pre></td></tr></table></figure>

<h3 id="fmt"><a href="#fmt" class="headerlink" title="fmt"></a>fmt</h3><p>实现了类似C语言<code>printf</code>和<code>scanf</code>的格式化I/O</p>
<h4 id="类型格式"><a href="#类型格式" class="headerlink" title="类型格式"></a>类型格式</h4><h5 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%v		值的默认格式表示</span><br><span class="line">%+v		类似%v，但输出结构体时会添加字段名</span><br><span class="line">%#v		值的go语法表示</span><br><span class="line">%T		值的类型的go语法表示</span><br><span class="line">%%		百分号</span><br></pre></td></tr></table></figure>

<h5 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%t		单词true或false</span><br></pre></td></tr></table></figure>

<h5 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%b		表示为二进制</span><br><span class="line">%c		该值对应的unicode码值</span><br><span class="line">%d		表示为十进制</span><br><span class="line">%o		表示为八进制</span><br><span class="line">%q		该值对应的单引号括起来的go语法字符字面值，必要时采用安全的转义表示</span><br><span class="line">%x		表示为十六进制，使用a-f</span><br><span class="line">%X		表示为十六进制，使用A-F</span><br><span class="line">%U		表示为Unicode格式：U+1234，等价于&quot;U+%04X&quot;</span><br></pre></td></tr></table></figure>

<h5 id="浮点数与复数"><a href="#浮点数与复数" class="headerlink" title="浮点数与复数"></a>浮点数与复数</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%b		无小数部分、二进制指数的科学计数法，如-123456p-78;</span><br><span class="line">%e		科学计数法，如-1234.456e+78</span><br><span class="line">%E		科学计数法，如-1234.456E+78</span><br><span class="line">%f		有小数部分但无指数部分，如123.456（在后面加入小数，个位表示宽度，小数位表示精度）</span><br><span class="line">%F		等价于%f</span><br><span class="line">%g		根据实际情况采用%e或%f格式（以获得更简洁、准确的输出）</span><br><span class="line">%G		根据实际情况采用%E或%F格式（以获得更简洁、准确的输出）</span><br></pre></td></tr></table></figure>

<h5 id="字符串与-byte"><a href="#字符串与-byte" class="headerlink" title="字符串与[]byte"></a>字符串与[]byte</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%s		直接输出字符串或者[]byte</span><br><span class="line">%q		该值对应双引号括起来的go语法字符串字面值，必要时采用安全的转义表示</span><br><span class="line">%x		每个字节用两字符十六进制数表示（使用a-f）</span><br><span class="line">%X		每个字节用两字符十六进制数表示（使用A-F）    </span><br></pre></td></tr></table></figure>

<h5 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%p		表示为十六进制，并加上前导的0x    </span><br><span class="line">fmt.Sprintf(&quot;%[2]d %[1]d\n&quot;, 11, 22)	//会生成&quot;22 11&quot;</span><br></pre></td></tr></table></figure>

<h4 id="向外输出"><a href="#向外输出" class="headerlink" title="向外输出"></a>向外输出</h4><h5 id="Print"><a href="#Print" class="headerlink" title="Print"></a>Print</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//直接输出内容</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Print</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>,err <span class="type">error</span>)</span><br><span class="line"><span class="comment">//支持格式化输出字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Printf</span><span class="params">(format <span class="type">string</span>,a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>,err <span class="type">error</span>)</span><br><span class="line"><span class="comment">//在输出内容结尾添加一个换行符</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Println</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>,err <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;名字是：%v\n&quot;</span>,<span class="string">&quot;lxx&quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;年龄是：%v\n&quot;</span>,<span class="number">19</span>)</span><br><span class="line">p:= <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">	age <span class="type">int</span></span><br><span class="line">&#125;&#123;<span class="string">&quot;lxx&quot;</span>,<span class="number">19</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;结构体内容为：%v\n&quot;</span>,p)</span><br><span class="line">fmt.Printf(<span class="string">&quot;结构体内容为(带字段名)：%+v\n&quot;</span>,p) <span class="comment">// 输出结构体是会带name</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;结构体内容为(值的Go语法表示)：%#v\n&quot;</span>,p) <span class="comment">// 输出结构体是会带name</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;切片内容为：%v\n&quot;</span>,[]<span class="type">int</span>&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;)</span><br><span class="line">fmt.Printf(<span class="string">&quot;切片内容为(值的Go语法表示)：%#v\n&quot;</span>,[]<span class="type">int</span>&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;切片值的类型为：%T\n&quot;</span>,[]<span class="type">int</span>&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;)</span><br><span class="line">fmt.Printf(<span class="string">&quot;字符串值的类型为：%T\n&quot;</span>,<span class="string">&quot;lxx&quot;</span>)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;打印百分百：100%%\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//名字是：lxx</span></span><br><span class="line"><span class="comment">//年龄是：19</span></span><br><span class="line"><span class="comment">//结构体内容为：&#123;lxx 19&#125;</span></span><br><span class="line"><span class="comment">//结构体内容为(带字段名)：&#123;name:lxx age:19&#125;</span></span><br><span class="line"><span class="comment">//结构体内容为(值的Go语法表示)：struct &#123; name string; age int &#125;&#123;name:&quot;lxx&quot;, age:19&#125;</span></span><br><span class="line"><span class="comment">//切片内容为：[4 5 6]</span></span><br><span class="line"><span class="comment">//切片内容为(值的Go语法表示)：[]int&#123;4, 5, 6&#125;</span></span><br><span class="line"><span class="comment">//切片值的类型为：[]int</span></span><br><span class="line"><span class="comment">//字符串值的类型为：string</span></span><br><span class="line"><span class="comment">//打印百分百：100%</span></span><br></pre></td></tr></table></figure>

<h5 id="Fprint"><a href="#Fprint" class="headerlink" title="Fprint"></a>Fprint</h5><p>将内容输出到一个<code>io.Writer</code>接口类型的变量<code>w</code>中，通常用该函数往文件中写入内容</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fprint</span><span class="params">(w io.Writer, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fprintf</span><span class="params">(w io.Writer, format <span class="type">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fprintln</span><span class="params">(w io.Writer, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//向标准输出写入内容</span></span><br><span class="line">    fmt.Fprint(os.Stdout,<span class="string">&quot;向标准输出（控制台）写入内容&quot;</span>)</span><br><span class="line">    fileObj,err := os.OpenFile(<span class="string">&quot;./xx.txt&quot;</span>,os.O_CREATE|os.O_WRONLY|os.O_APPEND, <span class="number">0644</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;打开文件出错，err:&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">    name := <span class="string">&quot;lxx is nb&quot;</span></span><br><span class="line">    <span class="comment">// 向打开的文件句柄中写入内容</span></span><br><span class="line">	fmt.Fprintf(fileObj, <span class="string">&quot;往文件中(标准输出)写如信息：%s&quot;</span>, name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Sprint"><a href="#Sprint" class="headerlink" title="Sprint"></a>Sprint</h5><p>将传入的数据生成并返回一个字符串</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sprint</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sprintf</span><span class="params">(format <span class="type">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sprintln</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">string</span></span><br><span class="line"></span><br><span class="line">s1 := fmt.Sprint(<span class="string">&quot;lxx&quot;</span>)</span><br><span class="line">name := <span class="string">&quot;lxx&quot;</span></span><br><span class="line">age := <span class="number">18</span></span><br><span class="line">s2 := fmt.Sprintf(<span class="string">&quot;姓名:%s,年龄:%d&quot;</span>, name, age)</span><br><span class="line">s3 := fmt.Sprintln(<span class="string">&quot;lxx is nb&quot;</span>)</span><br><span class="line">fmt.Println(s1, s2, s3)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Output: lxx 姓名:lxx,年龄:18 lxx is nb</span></span><br></pre></td></tr></table></figure>

<h4 id="获取输入"><a href="#获取输入" class="headerlink" title="获取输入"></a>获取输入</h4><h5 id="Scan"><a href="#Scan" class="headerlink" title="Scan"></a>Scan</h5><ul>
<li>从标准输入扫描文本，读取由空白字符分隔的值保存到传递给本函数的参数中，换行符视为空白符</li>
<li>返回成功扫描的数据个数和遇到的任何错误，若读取数据个数比提供的参数少，会返回一个错误报告原因</li>
<li><strong>若想完整获取输入的内容，而输入的内容可能包含空格，可以使用<code>bufio</code>中的方法</strong></li>
</ul>
<p><code>func Scan(a ...interface&#123;&#125;) (n int,err error)</code></p>
<h5 id="Scanf"><a href="#Scanf" class="headerlink" title="Scanf"></a>Scanf</h5><p><code>func Scanf(format string, a ...interface&#123;&#125;) (n int, err error)</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">)</span><br><span class="line">fmt.Scanf(<span class="string">&quot;name:%s age:%d&quot;</span>, &amp;name, &amp;age) <span class="comment">// 在控制台按照该格式输入</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;扫描结果： 姓名:%s 年龄:%d \n&quot;</span>, name, age)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制台按如下格式输入</span></span><br><span class="line"><span class="comment">//name:lxx age:19</span></span><br><span class="line"><span class="comment">//扫描结果： 姓名:lxx 年龄:19 </span></span><br></pre></td></tr></table></figure>

<h5 id="Scanln"><a href="#Scanln" class="headerlink" title="Scanln"></a>Scanln</h5><p>类似Scan，遇到换行时才停止扫描</p>
<p><code>func Scanln(a ...interface&#123;&#125;) (n int, err error)</code></p>
<h5 id="Fscan和Sscan"><a href="#Fscan和Sscan" class="headerlink" title="Fscan和Sscan"></a>Fscan和Sscan</h5><p>Fscan从<code>io.Reader</code>中读取数据，Sscan从指定字符串中读取数据</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fscan</span><span class="params">(r io.Reader, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fscanln</span><span class="params">(r io.Reader, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fscanf</span><span class="params">(r io.Reader, format <span class="type">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sscan</span><span class="params">(str <span class="type">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sscanln</span><span class="params">(str <span class="type">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sscanf</span><span class="params">(str <span class="type">string</span>, format <span class="type">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name <span class="type">string</span>=<span class="string">&quot;lxx&quot;</span></span><br><span class="line"><span class="keyword">var</span> newName <span class="type">string</span>=<span class="string">&quot;&quot;</span></span><br><span class="line">fmt.Sscan(name,&amp;newName) <span class="comment">// 相当于把name的值赋值给newName</span></span><br><span class="line">fmt.Println(name)</span><br><span class="line">fmt.Println(newName)</span><br></pre></td></tr></table></figure>

<h3 id="strings-和-strconv"><a href="#strings-和-strconv" class="headerlink" title="strings 和 strconv"></a>strings 和 strconv</h3><p>对于字符串的预定义处理函数</p>
<h4 id="前缀和后缀"><a href="#前缀和后缀" class="headerlink" title="前缀和后缀"></a>前缀和后缀</h4><p><code>HasPrefix()</code>判断字符串<code>s</code>是否以<code>prefix</code>开头</p>
<p><code>HasSuffix()</code> 判断字符串 <code>s</code> 是否以 <code>suffix</code> 结尾</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">strings.HasPrefix(s, prefix <span class="type">string</span>) <span class="type">bool</span></span><br><span class="line">strings.HasSuffix(s, suffix <span class="type">string</span>) <span class="type">bool</span></span><br></pre></td></tr></table></figure>

<h4 id="字符串包含关系"><a href="#字符串包含关系" class="headerlink" title="字符串包含关系"></a>字符串包含关系</h4><p><code>Contains()</code> 判断字符串 <code>s</code> 是否包含 <code>substr</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">strings.Contains(s, substr <span class="type">string</span>) <span class="type">bool</span></span><br></pre></td></tr></table></figure>

<p><code>Index()</code> 返回字符串 <code>str</code> 在字符串 <code>s</code> 中的索引（<code>str</code> 的第一个字符的索引），<code>-1</code> 表示字符串 <code>s</code> 不包含字符串 <code>str</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">strings.Index(s, str <span class="type">string</span>) <span class="type">int</span></span><br></pre></td></tr></table></figure>

<p><code>LastIndex()</code> 返回字符串 <code>str</code> 在字符串 <code>s</code> 中最后出现位置的索引（<code>str</code> 的第一个字符的索引），<code>-1</code> 表示字符串 <code>s</code> 不包含字符串 <code>str</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">strings.LastIndex(s, str <span class="type">string</span>) <span class="type">int</span></span><br></pre></td></tr></table></figure>

<p>若要查询非 ASCII 编码的字符在父字符串中的位置，建议使用以下函数定位</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">strings.IndexRune(s <span class="type">string</span>, r <span class="type">rune</span>) <span class="type">int</span></span><br></pre></td></tr></table></figure>

<h4 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h4><p><code>Replace()</code> 用于将字符串 <code>str</code> 中的前 <code>n</code> 个字符串 <code>old</code> 替换为字符串 <code>new</code>，并返回一个新的字符串，如果 <code>n = -1</code> 则替换所有字符串 <code>old</code> 为字符串 <code>new</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">strings.Replace(str, old, <span class="built_in">new</span> <span class="type">string</span>, n <span class="type">int</span>) <span class="type">string</span></span><br></pre></td></tr></table></figure>

<h4 id="字符串出现次数"><a href="#字符串出现次数" class="headerlink" title="字符串出现次数"></a>字符串出现次数</h4><p><code>Count()</code> 用于计算字符串 <code>str</code> 在字符串 <code>s</code> 中出现的非重叠次数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">strings.Count(s, str <span class="type">string</span>) <span class="type">int</span></span><br></pre></td></tr></table></figure>

<h4 id="重复字符串"><a href="#重复字符串" class="headerlink" title="重复字符串"></a>重复字符串</h4><p><code>Repeat()</code> 用于重复 <code>count</code> 次字符串 <code>s</code> 并返回一个新的字符串</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">strings.Repeat(s, count <span class="type">int</span>) <span class="type">string</span></span><br></pre></td></tr></table></figure>

<h4 id="修改字符串大小写"><a href="#修改字符串大小写" class="headerlink" title="修改字符串大小写"></a>修改字符串大小写</h4><p><code>ToLower()</code> 将字符串中的 Unicode 字符全部转换为相应的小写字符</p>
<p><code>ToUpper()</code> 将字符串中的 Unicode 字符全部转换为相应的大写字符</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">strings.ToLower(s) <span class="type">string</span></span><br><span class="line">strings.ToUpper(s) <span class="type">string</span></span><br></pre></td></tr></table></figure>

<h4 id="修剪字符串"><a href="#修剪字符串" class="headerlink" title="修剪字符串"></a>修剪字符串</h4><p>使用 <code>strings.TrimSpace(s)</code> 来剔除字符串开头和结尾的空白符号；若想剔除指定字符，可以使用 <code>strings.Trim(s, &quot;cut&quot;)</code> 来将开头和结尾的 <code>cut</code> 去除掉。该函数的第二个参数可以包含任何字符，若只想剔除开头或者结尾的字符串，则可以使用 <code>TrimLeft()</code> 或者 <code>TrimRight()</code> 来实现</p>
<h4 id="分割字符串"><a href="#分割字符串" class="headerlink" title="分割字符串"></a>分割字符串</h4><p><code>strings.Fields(s)</code> 将会利用 1 个或多个空白符号来作为动态长度的分隔符将字符串分割成若干小块，并返回一个 slice，如果字符串只包含空白符号，则返回一个长度为 0 的 slice</p>
<p><code>strings.Split(s, sep)</code> 用于自定义分割符号进行分割，同样返回 slice</p>
<p>因为这 2 个函数都会返回 slice，所以习惯使用 for-range 循环来对其进行处理</p>
<h4 id="拼接slice到字符串"><a href="#拼接slice到字符串" class="headerlink" title="拼接slice到字符串"></a>拼接slice到字符串</h4><p><code>Join()</code> 用于将元素类型为 string 的 slice 用分割符号来拼接组成一个字符串</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">strings.Join(sl []<span class="type">string</span>, sep <span class="type">string</span>) <span class="type">string</span></span><br></pre></td></tr></table></figure>

<h4 id="从字符串中读取内容"><a href="#从字符串中读取内容" class="headerlink" title="从字符串中读取内容"></a>从字符串中读取内容</h4><p> <code>strings.NewReader(str)</code> 用于生成一个 <code>Reader</code> 并读取字符串中的内容，然后返回指向该 <code>Reader</code> 的指针，从其它类型读取内容的函数还有：</p>
<ul>
<li><code>Read()</code> 从 <code>[]byte</code> 中读取内容</li>
<li><code>ReadByte()</code> 和 <code>ReadRune()</code> 从字符串中读取下一个 <code>byte</code> 或者 <code>rune</code></li>
</ul>
<h4 id="字符串与其它类型的转换"><a href="#字符串与其它类型的转换" class="headerlink" title="字符串与其它类型的转换"></a>字符串与其它类型的转换</h4><p>与字符串相关的类型转换都是通过 <code>strconv</code> 包实现的，任何类型<code>T</code>转换为字符串总是成功的</p>
<p>针对从数字类型转换到字符串，Go 提供了以下函数：</p>
<ul>
<li><code>strconv.Itoa(i int) string</code> 返回数字 <code>i</code> 表示的字符串类型的十进制数</li>
<li><code>strconv.FormatFloat(f float64, fmt byte, prec int, bitSize int) string</code>将 64 位浮点型的数字转换为字符串，其中 <code>fmt</code> 表示格式（其值可以是 <code>&#39;b&#39;</code>、<code>&#39;e&#39;</code>、<code>&#39;f&#39;</code> 或 <code>&#39;g&#39;</code>），<code>prec</code> 表示精度，<code>bitSize</code> 则使用 32 表示 <code>float32</code>，用 64 表示 <code>float64</code></li>
</ul>
<p>针对从字符串类型转换为数字类型，Go 提供了以下函数：</p>
<ul>
<li><code>strconv.Atoi(s string) (i int, err error)</code> 将字符串转换为 <code>int</code> 型</li>
<li><code>strconv.ParseFloat(s string, bitSize int) (f float64, err error)</code> 将字符串转换为 <code>float64</code> 型</li>
</ul>
<h3 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Constants</span></span><br><span class="line"><span class="comment">Variables</span></span><br><span class="line"><span class="comment">func Copy(dst Writer, src Reader) (written int64, err error)</span></span><br><span class="line"><span class="comment">func CopyBuffer(dst Writer, src Reader, buf []byte) (written int64, err error)</span></span><br><span class="line"><span class="comment">func CopyN(dst Writer, src Reader, n int64) (written int64, err error)</span></span><br><span class="line"><span class="comment">func Pipe() (*PipeReader, *PipeWriter)</span></span><br><span class="line"><span class="comment">func ReadAll(r Reader) ([]byte, error)</span></span><br><span class="line"><span class="comment">func ReadAtLeast(r Reader, buf []byte, min int) (n int, err error)</span></span><br><span class="line"><span class="comment">func ReadFull(r Reader, buf []byte) (n int, err error)</span></span><br><span class="line"><span class="comment">func WriteString(w Writer, s string) (n int, err error)</span></span><br><span class="line"><span class="comment">type ByteReader</span></span><br><span class="line"><span class="comment">type ByteScanner</span></span><br><span class="line"><span class="comment">type ByteWriter</span></span><br><span class="line"><span class="comment">type Closer</span></span><br><span class="line"><span class="comment">type LimitedReader</span></span><br><span class="line"><span class="comment">	func (l *LimitedReader) Read(p []byte) (n int, err error)</span></span><br><span class="line"><span class="comment">type PipeReader</span></span><br><span class="line"><span class="comment">	func (r *PipeReader) Close() error</span></span><br><span class="line"><span class="comment">	func (r *PipeReader) CloseWithError(err error) error</span></span><br><span class="line"><span class="comment">	func (r *PipeReader) Read(data []byte) (n int, err error)</span></span><br><span class="line"><span class="comment">type PipeWriter</span></span><br><span class="line"><span class="comment">	func (w *PipeWriter) Close() error</span></span><br><span class="line"><span class="comment">	func (w *PipeWriter) CloseWithError(err error) error</span></span><br><span class="line"><span class="comment">	func (w *PipeWriter) Write(data []byte) (n int, err error)</span></span><br><span class="line"><span class="comment">type ReadCloser</span></span><br><span class="line"><span class="comment">func NopCloser(r Reader) ReadCloser</span></span><br><span class="line"><span class="comment">type ReadSeekCloser</span></span><br><span class="line"><span class="comment">type ReadSeeker</span></span><br><span class="line"><span class="comment">type ReadWriteCloser</span></span><br><span class="line"><span class="comment">type ReadWriteSeeker</span></span><br><span class="line"><span class="comment">type ReadWriter</span></span><br><span class="line"><span class="comment">type Reader</span></span><br><span class="line"><span class="comment">	func LimitReader(r Reader, n int64) Reader</span></span><br><span class="line"><span class="comment">	func MultiReader(readers ...Reader) Reader</span></span><br><span class="line"><span class="comment">	func TeeReader(r Reader, w Writer) Reader</span></span><br><span class="line"><span class="comment">type ReaderAt</span></span><br><span class="line"><span class="comment">type ReaderFrom</span></span><br><span class="line"><span class="comment">type RuneReader</span></span><br><span class="line"><span class="comment">type RuneScanner</span></span><br><span class="line"><span class="comment">type SectionReader</span></span><br><span class="line"><span class="comment">	func NewSectionReader(r ReaderAt, off int64, n int64) *SectionReader</span></span><br><span class="line"><span class="comment">	func (s *SectionReader) Read(p []byte) (n int, err error)</span></span><br><span class="line"><span class="comment">	func (s *SectionReader) ReadAt(p []byte, off int64) (n int, err error)</span></span><br><span class="line"><span class="comment">	func (s *SectionReader) Seek(offset int64, whence int) (int64, error)</span></span><br><span class="line"><span class="comment">	func (s *SectionReader) Size() int64</span></span><br><span class="line"><span class="comment">type Seeker</span></span><br><span class="line"><span class="comment">type StringWriter</span></span><br><span class="line"><span class="comment">type WriteCloser</span></span><br><span class="line"><span class="comment">type WriteSeeker</span></span><br><span class="line"><span class="comment">type Writer</span></span><br><span class="line"><span class="comment">	func MultiWriter(writers ...Writer) Writer</span></span><br><span class="line"><span class="comment">type WriterAt</span></span><br><span class="line"><span class="comment">type WriterTo</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *func Copy(dst Writer,src Reader) (written int64,err error)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    r := strings.NewReader(<span class="string">&quot;some io.Reader stream to be read&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> _, err := io.Copy(os.Stdout, r); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *func Pipe() (*PipeReader,*PipeWriter)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    r,w := io.Pipe()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Fprint(w,<span class="string">&quot;some io.Reader stream to be read\n&quot;</span>)</span><br><span class="line">        w.Close()</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">if</span> _,err := io.Copy(os.Stdout,r); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="log（提供日志操作的函数和方法）"><a href="#log（提供日志操作的函数和方法）" class="headerlink" title="log（提供日志操作的函数和方法）"></a>log（提供日志操作的函数和方法）</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Constants</span></span><br><span class="line"><span class="comment">func Fatal(v ...interface&#123;&#125;)</span></span><br><span class="line"><span class="comment">func Fatalf(format string, v ...interface&#123;&#125;)</span></span><br><span class="line"><span class="comment">func Fatalln(v ...interface&#123;&#125;)</span></span><br><span class="line"><span class="comment">func Flags() int</span></span><br><span class="line"><span class="comment">func Output(calldepth int, s string) error</span></span><br><span class="line"><span class="comment">func Panic(v ...interface&#123;&#125;)</span></span><br><span class="line"><span class="comment">func Panicf(format string, v ...interface&#123;&#125;)</span></span><br><span class="line"><span class="comment">func Panicln(v ...interface&#123;&#125;)</span></span><br><span class="line"><span class="comment">func Prefix() string</span></span><br><span class="line"><span class="comment">func Print(v ...interface&#123;&#125;)</span></span><br><span class="line"><span class="comment">func Printf(format string, v ...interface&#123;&#125;)</span></span><br><span class="line"><span class="comment">func Println(v ...interface&#123;&#125;)</span></span><br><span class="line"><span class="comment">func SetFlags(flag int)</span></span><br><span class="line"><span class="comment">func SetOutput(w io.Writer)</span></span><br><span class="line"><span class="comment">func SetPrefix(prefix string)</span></span><br><span class="line"><span class="comment">func Writer() io.Writer</span></span><br><span class="line"><span class="comment">type Logger</span></span><br><span class="line"><span class="comment">	func Default() *Logger</span></span><br><span class="line"><span class="comment">	func New(out io.Writer, prefix string, flag int) *Logger</span></span><br><span class="line"><span class="comment">	func (l *Logger) Fatal(v ...interface&#123;&#125;)</span></span><br><span class="line"><span class="comment">	func (l *Logger) Fatalf(format string, v ...interface&#123;&#125;)</span></span><br><span class="line"><span class="comment">	func (l *Logger) Fatalln(v ...interface&#123;&#125;)</span></span><br><span class="line"><span class="comment">	func (l *Logger) Flags() int</span></span><br><span class="line"><span class="comment">	func (l *Logger) Output(calldepth int, s string) error</span></span><br><span class="line"><span class="comment">	func (l *Logger) Panic(v ...interface&#123;&#125;)</span></span><br><span class="line"><span class="comment">	func (l *Logger) Panicf(format string, v ...interface&#123;&#125;)</span></span><br><span class="line"><span class="comment">	func (l *Logger) Panicln(v ...interface&#123;&#125;)</span></span><br><span class="line"><span class="comment">	func (l *Logger) Prefix() string</span></span><br><span class="line"><span class="comment">	func (l *Logger) Print(v ...interface&#123;&#125;)</span></span><br><span class="line"><span class="comment">	func (l *Logger) Printf(format string, v ...interface&#123;&#125;)</span></span><br><span class="line"><span class="comment">	func (l *Logger) Println(v ...interface&#123;&#125;)</span></span><br><span class="line"><span class="comment">	func (l *Logger) SetFlags(flag int)</span></span><br><span class="line"><span class="comment">	func (l *Logger) SetOutput(w io.Writer)</span></span><br><span class="line"><span class="comment">	func (l *Logger) SetPrefix(prefix string)</span></span><br><span class="line"><span class="comment">	func (l *Logger) Writer() io.Writer</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Print类：跟fmt差不多，只是前面加了格式</span></span><br><span class="line">    <span class="comment">// Fatal类：日志输出后，系统调用os.exit(1)，整个程序退出，若后面有defer，也不执行</span></span><br><span class="line">    <span class="comment">// Panic类：日志输出后，发生Panic</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	Fatal等价于&#123;Print(v...);os.Exit(1)&#125;</span></span><br><span class="line"><span class="comment">    *func Fatal(v ...interface&#123;&#125;)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    log.Fatal(<span class="string">&quot;hello啊树先生，执行后终止&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;你执行了吗？&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	SetFlags设置标准logger的输出选项</span></span><br><span class="line"><span class="comment">    *func SetFlags(flag int)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    log.SetFlags(log.Ldate|log.Ltime|log.LUTC)</span><br><span class="line">    log.Println(<span class="string">&quot;sddfgfgh&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	SetOutput设置标准logger的输出目的地，默认是标准错误输出</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    file,_ := os.Create(<span class="string">&quot;sdk/testLog&quot;</span>)</span><br><span class="line">    log.SetOutput(file)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sort（按照一定规则对元素进行相关排序）"><a href="#sort（按照一定规则对元素进行相关排序）" class="headerlink" title="sort（按照一定规则对元素进行相关排序）"></a>sort（按照一定规则对元素进行相关排序）</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">func Float64s(x []float64)</span></span><br><span class="line"><span class="comment">func Float64sAreSorted(x []float64) bool</span></span><br><span class="line"><span class="comment">func Ints(x []int)</span></span><br><span class="line"><span class="comment">func IntsAreSorted(x []int) bool</span></span><br><span class="line"><span class="comment">func IsSorted(data Interface) bool</span></span><br><span class="line"><span class="comment">func Search(n int, f func(int) bool) int</span></span><br><span class="line"><span class="comment">func SearchFloat64s(a []float64, x float64) int</span></span><br><span class="line"><span class="comment">func SearchInts(a []int, x int) int</span></span><br><span class="line"><span class="comment">func SearchStrings(a []string, x string) int</span></span><br><span class="line"><span class="comment">func Slice(x interface&#123;&#125;, less func(i, j int) bool)</span></span><br><span class="line"><span class="comment">func SliceIsSorted(x interface&#123;&#125;, less func(i, j int) bool) bool</span></span><br><span class="line"><span class="comment">func SliceStable(x interface&#123;&#125;, less func(i, j int) bool)</span></span><br><span class="line"><span class="comment">func Sort(data Interface)</span></span><br><span class="line"><span class="comment">func Stable(data Interface)</span></span><br><span class="line"><span class="comment">func Strings(x []string)</span></span><br><span class="line"><span class="comment">func StringsAreSorted(x []string) bool</span></span><br><span class="line"><span class="comment">type Float64Slice</span></span><br><span class="line"><span class="comment">	func (x Float64Slice) Len() int</span></span><br><span class="line"><span class="comment">	func (x Float64Slice) Less(i, j int) bool</span></span><br><span class="line"><span class="comment">	func (p Float64Slice) Search(x float64) int</span></span><br><span class="line"><span class="comment">	func (x Float64Slice) Sort()</span></span><br><span class="line"><span class="comment">	func (x Float64Slice) Swap(i, j int)</span></span><br><span class="line"><span class="comment">type IntSlice</span></span><br><span class="line"><span class="comment">	func (x IntSlice) Len() int</span></span><br><span class="line"><span class="comment">	func (x IntSlice) Less(i, j int) bool</span></span><br><span class="line"><span class="comment">	func (p IntSlice) Search(x int) int</span></span><br><span class="line"><span class="comment">	func (x IntSlice) Sort()</span></span><br><span class="line"><span class="comment">	func (x IntSlice) Swap(i, j int)</span></span><br><span class="line"><span class="comment">type Interface</span></span><br><span class="line"><span class="comment">	func Reverse(data Interface) Interface</span></span><br><span class="line"><span class="comment">type StringSlice</span></span><br><span class="line"><span class="comment">	func (x StringSlice) Len() int</span></span><br><span class="line"><span class="comment">	func (x StringSlice) Less(i, j int) bool</span></span><br><span class="line"><span class="comment">	func (p StringSlice) Search(x string) int</span></span><br><span class="line"><span class="comment">	func (x StringSlice) Sort()</span></span><br><span class="line"><span class="comment">	func (x StringSlice) Swap(i, j int)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	Float64s按递增顺序对float64s的一部分进行排序，Not-a-number(NaN)值先于其他值排序</span></span><br><span class="line"><span class="comment">    *func Float64s(x []float64)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    s := []<span class="type">float64</span>&#123;math.Inf(<span class="number">1</span>), math.NaN(), math.Inf(<span class="number">-1</span>), <span class="number">0.0</span>&#125;</span><br><span class="line">	sort.Float64s(s)</span><br><span class="line">	fmt.Println(s)</span><br><span class="line">    <span class="comment">/*输出：[NaN -Inf 0 +Inf]*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	Float64sAreSorted报告切片x是否以递增的顺序排序，其中not-a-number(NaN)值位于任何其他值之前</span></span><br><span class="line"><span class="comment">    *func Float64sAreSorted(x []float64) bool</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	Search使用二分法进行查找</span></span><br><span class="line"><span class="comment">    *func Search(n int,f func(int) bool) int</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    a := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">21</span>,<span class="number">28</span>,<span class="number">36</span>,<span class="number">45</span>,<span class="number">55</span>&#125;</span><br><span class="line">    x := <span class="number">6</span></span><br><span class="line">    </span><br><span class="line">    i := sort.Search(<span class="built_in">len</span>(a),<span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;<span class="keyword">return</span> a[i] &gt;= x&#125;)</span><br><span class="line">    <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(a) &amp;&amp; a[i] == x &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;found %d at index %d in %v\n&quot;</span>, x, i, a)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%d not found in %v\n&quot;</span>, x, a)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	返回x在a中应该存在的位置，无论a中是否存在a中在递增顺序的a中搜索x，返回x的索引。如果查找不到，返回值是x应该插入a的位置（以保证a的递增顺序），返回值可以是len(a)</span></span><br><span class="line"><span class="comment">    *func SearchInts(a []int,x int) int	&#123;</span></span><br><span class="line"><span class="comment">    	return Search(len(a),func(i int) bool &#123;return a[i]&gt;=x&#125;)</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    s := []<span class="type">int</span>&#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>&#125;</span><br><span class="line">	index := sort.SearchInts(s, <span class="number">5</span>)</span><br><span class="line">	fmt.Println(index)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	字符串按升序对字符串的一部分进行排序</span></span><br><span class="line"><span class="comment">    *func Strings(x []string)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    s := []<span class="type">string</span>&#123;<span class="string">&quot;Go&quot;</span>, <span class="string">&quot;Bravo&quot;</span>, <span class="string">&quot;Gopher&quot;</span>, <span class="string">&quot;Alpha&quot;</span>, <span class="string">&quot;Grin&quot;</span>, <span class="string">&quot;Delta&quot;</span>&#125;</span><br><span class="line">	sort.Strings(s)</span><br><span class="line">	fmt.Println(s)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	求FloatSlice的数据类型的长度</span></span><br><span class="line"><span class="comment">    *func (x Float64Slice) Len() int</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">var</span> x sort.Float64Slice</span><br><span class="line">	x = []<span class="type">float64</span>&#123;<span class="number">74.3</span>, <span class="number">59.0</span>, math.Inf(<span class="number">1</span>), <span class="number">238.2</span>, <span class="number">-784.0</span>, <span class="number">2.3</span>, math.NaN(), math.NaN(), </span><br><span class="line">        math.Inf(<span class="number">-1</span>), <span class="number">9845.768</span>, <span class="number">-959.7485</span>, <span class="number">905</span>, <span class="number">7.8</span>, <span class="number">7.8</span>&#125;</span><br><span class="line">	fmt.Println(x.Len())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="OS（底层相关的函数和方法）"><a href="#OS（底层相关的函数和方法）" class="headerlink" title="OS（底层相关的函数和方法）"></a>OS（底层相关的函数和方法）</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Constants</span></span><br><span class="line"><span class="comment">Variables</span></span><br><span class="line"><span class="comment">func Chdir(dir string) error</span></span><br><span class="line"><span class="comment">func Chmod(name string, mode FileMode) error</span></span><br><span class="line"><span class="comment">func Chown(name string, uid, gid int) error</span></span><br><span class="line"><span class="comment">func Chtimes(name string, atime time.Time, mtime time.Time) error</span></span><br><span class="line"><span class="comment">func Clearenv()</span></span><br><span class="line"><span class="comment">func DirFS(dir string) fs.FS</span></span><br><span class="line"><span class="comment">func Environ() []string</span></span><br><span class="line"><span class="comment">func Executable() (string, error)</span></span><br><span class="line"><span class="comment">func Exit(code int)</span></span><br><span class="line"><span class="comment">func Expand(s string, mapping func(string) string) string</span></span><br><span class="line"><span class="comment">func ExpandEnv(s string) string</span></span><br><span class="line"><span class="comment">func Getegid() int</span></span><br><span class="line"><span class="comment">func Getenv(key string) string</span></span><br><span class="line"><span class="comment">func Geteuid() int</span></span><br><span class="line"><span class="comment">func Getgid() int</span></span><br><span class="line"><span class="comment">func Getgroups() ([]int, error)</span></span><br><span class="line"><span class="comment">func Getpagesize() int</span></span><br><span class="line"><span class="comment">func Getpid() int</span></span><br><span class="line"><span class="comment">func Getppid() int</span></span><br><span class="line"><span class="comment">func Getuid() int</span></span><br><span class="line"><span class="comment">func Getwd() (dir string, err error)</span></span><br><span class="line"><span class="comment">func Hostname() (name string, err error)</span></span><br><span class="line"><span class="comment">func IsExist(err error) bool</span></span><br><span class="line"><span class="comment">func IsNotExist(err error) bool</span></span><br><span class="line"><span class="comment">func IsPathSeparator(c uint8) bool</span></span><br><span class="line"><span class="comment">func IsPermission(err error) bool</span></span><br><span class="line"><span class="comment">func IsTimeout(err error) bool</span></span><br><span class="line"><span class="comment">func Lchown(name string, uid, gid int) error</span></span><br><span class="line"><span class="comment">func Link(oldname, newname string) error</span></span><br><span class="line"><span class="comment">func LookupEnv(key string) (string, bool)</span></span><br><span class="line"><span class="comment">func Mkdir(name string, perm FileMode) error</span></span><br><span class="line"><span class="comment">func MkdirAll(path string, perm FileMode) error</span></span><br><span class="line"><span class="comment">func MkdirTemp(dir, pattern string) (string, error)</span></span><br><span class="line"><span class="comment">func NewSyscallError(syscall string, err error) error</span></span><br><span class="line"><span class="comment">func Pipe() (r *File, w *File, err error)</span></span><br><span class="line"><span class="comment">func ReadFile(name string) ([]byte, error)</span></span><br><span class="line"><span class="comment">func Readlink(name string) (string, error)</span></span><br><span class="line"><span class="comment">func Remove(name string) error</span></span><br><span class="line"><span class="comment">func RemoveAll(path string) error</span></span><br><span class="line"><span class="comment">func Rename(oldpath, newpath string) error</span></span><br><span class="line"><span class="comment">func SameFile(fi1, fi2 FileInfo) bool</span></span><br><span class="line"><span class="comment">func Setenv(key, value string) error</span></span><br><span class="line"><span class="comment">func Symlink(oldname, newname string) error</span></span><br><span class="line"><span class="comment">func TempDir() string</span></span><br><span class="line"><span class="comment">func Truncate(name string, size int64) error</span></span><br><span class="line"><span class="comment">func Unsetenv(key string) error</span></span><br><span class="line"><span class="comment">func UserCacheDir() (string, error)</span></span><br><span class="line"><span class="comment">func UserConfigDir() (string, error)</span></span><br><span class="line"><span class="comment">func UserHomeDir() (string, error)</span></span><br><span class="line"><span class="comment">func WriteFile(name string, data []byte, perm FileMode) error</span></span><br><span class="line"><span class="comment">type DirEntry</span></span><br><span class="line"><span class="comment">	func ReadDir(name string) ([]DirEntry, error)</span></span><br><span class="line"><span class="comment">type File</span></span><br><span class="line"><span class="comment">	func Create(name string) (*File, error)</span></span><br><span class="line"><span class="comment">	func CreateTemp(dir, pattern string) (*File, error)</span></span><br><span class="line"><span class="comment">	func NewFile(fd uintptr, name string) *File</span></span><br><span class="line"><span class="comment">	func Open(name string) (*File, error)</span></span><br><span class="line"><span class="comment">	func OpenFile(name string, flag int, perm FileMode) (*File, error)</span></span><br><span class="line"><span class="comment">	func (f *File) Chdir() error</span></span><br><span class="line"><span class="comment">	func (f *File) Chmod(mode FileMode) error</span></span><br><span class="line"><span class="comment">	func (f *File) Chown(uid, gid int) error</span></span><br><span class="line"><span class="comment">	func (f *File) Close() error</span></span><br><span class="line"><span class="comment">	func (f *File) Fd() uintptr</span></span><br><span class="line"><span class="comment">	func (f *File) Name() string</span></span><br><span class="line"><span class="comment">	func (f *File) Read(b []byte) (n int, err error)</span></span><br><span class="line"><span class="comment">	func (f *File) ReadAt(b []byte, off int64) (n int, err error)</span></span><br><span class="line"><span class="comment">	func (f *File) ReadDir(n int) ([]DirEntry, error)</span></span><br><span class="line"><span class="comment">	func (f *File) ReadFrom(r io.Reader) (n int64, err error)</span></span><br><span class="line"><span class="comment">	func (f *File) Readdir(n int) ([]FileInfo, error)</span></span><br><span class="line"><span class="comment">	func (f *File) Readdirnames(n int) (names []string, err error)</span></span><br><span class="line"><span class="comment">	func (f *File) Seek(offset int64, whence int) (ret int64, err error)</span></span><br><span class="line"><span class="comment">	func (f *File) SetDeadline(t time.Time) error</span></span><br><span class="line"><span class="comment">	func (f *File) SetReadDeadline(t time.Time) error</span></span><br><span class="line"><span class="comment">	func (f *File) SetWriteDeadline(t time.Time) error</span></span><br><span class="line"><span class="comment">	func (f *File) Stat() (FileInfo, error)</span></span><br><span class="line"><span class="comment">	func (f *File) Sync() error</span></span><br><span class="line"><span class="comment">	func (f *File) SyscallConn() (syscall.RawConn, error)</span></span><br><span class="line"><span class="comment">	func (f *File) Truncate(size int64) error</span></span><br><span class="line"><span class="comment">	func (f *File) Write(b []byte) (n int, err error)</span></span><br><span class="line"><span class="comment">	func (f *File) WriteAt(b []byte, off int64) (n int, err error)</span></span><br><span class="line"><span class="comment">	func (f *File) WriteString(s string) (n int, err error)</span></span><br><span class="line"><span class="comment">type FileInfo</span></span><br><span class="line"><span class="comment">	func Lstat(name string) (FileInfo, error)</span></span><br><span class="line"><span class="comment">	func Stat(name string) (FileInfo, error)</span></span><br><span class="line"><span class="comment">type FileMode</span></span><br><span class="line"><span class="comment">type LinkError</span></span><br><span class="line"><span class="comment">	func (e *LinkError) Error() string</span></span><br><span class="line"><span class="comment">	func (e *LinkError) Unwrap() error</span></span><br><span class="line"><span class="comment">type PathError</span></span><br><span class="line"><span class="comment">type ProcAttr</span></span><br><span class="line"><span class="comment">type Process</span></span><br><span class="line"><span class="comment">	func FindProcess(pid int) (*Process, error)</span></span><br><span class="line"><span class="comment">	func StartProcess(name string, argv []string, attr *ProcAttr) (*Process, error)</span></span><br><span class="line"><span class="comment">	func (p *Process) Kill() error</span></span><br><span class="line"><span class="comment">	func (p *Process) Release() error</span></span><br><span class="line"><span class="comment">	func (p *Process) Signal(sig Signal) error</span></span><br><span class="line"><span class="comment">	func (p *Process) Wait() (*ProcessState, error)</span></span><br><span class="line"><span class="comment">type ProcessState</span></span><br><span class="line"><span class="comment">	func (p *ProcessState) ExitCode() int</span></span><br><span class="line"><span class="comment">	func (p *ProcessState) Exited() bool</span></span><br><span class="line"><span class="comment">	func (p *ProcessState) Pid() int</span></span><br><span class="line"><span class="comment">	func (p *ProcessState) String() string</span></span><br><span class="line"><span class="comment">	func (p *ProcessState) Success() bool</span></span><br><span class="line"><span class="comment">	func (p *ProcessState) Sys() interface&#123;&#125;</span></span><br><span class="line"><span class="comment">	func (p *ProcessState) SysUsage() interface&#123;&#125;</span></span><br><span class="line"><span class="comment">	func (p *ProcessState) SystemTime() time.Duration</span></span><br><span class="line"><span class="comment">	func (p *ProcessState) UserTime() time.Duration</span></span><br><span class="line"><span class="comment">type Signal</span></span><br><span class="line"><span class="comment">type SyscallError</span></span><br><span class="line"><span class="comment">	func (e *SyscallError) Error() string</span></span><br><span class="line"><span class="comment">	func (e *SyscallError) Timeout() bool</span></span><br><span class="line"><span class="comment">	func (e *SyscallError) Unwrap() error</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	Chdir将当前工作目录更改为指定的目录，若有错，将是*PathError类型</span></span><br><span class="line"><span class="comment">    *func Chdir(dir string) error</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    beforeDir,_ := os.Getwd()</span><br><span class="line">    fmt.Println(beforeDir)</span><br><span class="line">    err := os.Chdir(<span class="string">&quot;sdk/test&quot;</span>)</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    latestDir,_ := os.Getwd()</span><br><span class="line">    fmt.Println(latestDir)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	Chmod更改文件模式，若文件是符号链接将更改链接目标的模式</span></span><br><span class="line"><span class="comment">    *func Chmod(name string,mode FileMode) error</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> err := os.Chmod(<span class="string">&quot;sdk/test.txt&quot;</span>,<span class="number">0644</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	Chown 更改文件的uid（用户唯一标识符）和gid（用户组唯一标识符），若文件是符号链接则会更改链接目标</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> err := os.Lchown(FilePath, <span class="number">501</span>, <span class="number">20</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	Chtimes 更改指定文件的访问和修改时间，类似于Unix utime()或utimes()函数</span></span><br><span class="line"><span class="comment">    *func Chtimes(name string, atime time.Time, mtime time.Time) error</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    mtime := time.Date(<span class="number">2006</span>,time.February,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">0</span>,time.UTC)</span><br><span class="line">    atime := time.Date(<span class="number">2007</span>,time.March,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">0</span>,time.UTC)</span><br><span class="line">    <span class="keyword">if</span> err := os.Chtimes(<span class="string">&quot;some-filename&quot;</span>, atime, mtime); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	Clearenv 删除所有环境变量</span></span><br><span class="line"><span class="comment">    *func Clearenv()</span></span><br><span class="line"><span class="comment">        DirFS返回文件系统操作对象</span></span><br><span class="line"><span class="comment">    *func DirFS(dir string) fs.FS</span></span><br><span class="line"><span class="comment">    	Executable可执行文件返回启动当前进程的可执行文件的路径名称</span></span><br><span class="line"><span class="comment">    *func Executable() (string,error)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	*Expand根据映射函数替换字符串中的$&#123;var&#125;或$var。例如，os.ExpandEnv(s)</span></span><br><span class="line"><span class="comment">	*等效于os.Expand(s，os.Getenv)。</span></span><br><span class="line"><span class="comment">	*func Expand(s string, mapping func(string) string) string</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	mapper := <span class="function"><span class="keyword">func</span><span class="params">(placeholderName <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">		<span class="keyword">switch</span> placeholderName &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;DAY_PART&quot;</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;morning&quot;</span></span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;NAME&quot;</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;Gopher&quot;</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(os.Expand(<span class="string">&quot;Good $&#123;DAY_PART&#125;, $NAME!&quot;</span>, mapper))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	ExpandEnv根据当前环境变量的值替换字符串中的$&#123;var&#125;或$var，未定义变量的引用将替换为空字符串</span></span><br><span class="line"><span class="comment">    *func ExpandEnv(s string) string</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    os.Setenv(<span class="string">&quot;NAME&quot;</span>, <span class="string">&quot;gopher&quot;</span>)</span><br><span class="line">	os.Setenv(<span class="string">&quot;BURROW&quot;</span>, <span class="string">&quot;/usr/gopher&quot;</span>)</span><br><span class="line">	fmt.Println(os.ExpandEnv(<span class="string">&quot;$NAME lives in $&#123;BURROW&#125;.&quot;</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	Getegid 返回调用者的数字有效组ID</span></span><br><span class="line"><span class="comment">    *func Getegid() int</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	Hostname返回内核提供的主机名</span></span><br><span class="line"><span class="comment">    	func Hostname() (name string,err error)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="time"><a href="#time" class="headerlink" title="time"></a>time</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Constants</span></span><br><span class="line"><span class="comment">func After(d Duration) &lt;-chan Time</span></span><br><span class="line"><span class="comment">func Sleep(d Duration)</span></span><br><span class="line"><span class="comment">func Tick(d Duration) &lt;-chan Time</span></span><br><span class="line"><span class="comment">type Duration</span></span><br><span class="line"><span class="comment">	func ParseDuration(s string) (Duration, error)</span></span><br><span class="line"><span class="comment">	func Since(t Time) Duration</span></span><br><span class="line"><span class="comment">	func Until(t Time) Duration</span></span><br><span class="line"><span class="comment">	func (d Duration) Hours() float64</span></span><br><span class="line"><span class="comment">	func (d Duration) Microseconds() int64</span></span><br><span class="line"><span class="comment">	func (d Duration) Milliseconds() int64</span></span><br><span class="line"><span class="comment">	func (d Duration) Minutes() float64</span></span><br><span class="line"><span class="comment">	func (d Duration) Nanoseconds() int64</span></span><br><span class="line"><span class="comment">	func (d Duration) Round(m Duration) Duration</span></span><br><span class="line"><span class="comment">	func (d Duration) Seconds() float64</span></span><br><span class="line"><span class="comment">	func (d Duration) String() string</span></span><br><span class="line"><span class="comment">	func (d Duration) Truncate(m Duration) Duration</span></span><br><span class="line"><span class="comment">type Location</span></span><br><span class="line"><span class="comment">	func FixedZone(name string, offset int) *Location</span></span><br><span class="line"><span class="comment">	func LoadLocation(name string) (*Location, error)</span></span><br><span class="line"><span class="comment">	func LoadLocationFromTZData(name string, data []byte) (*Location, error)</span></span><br><span class="line"><span class="comment">	func (l *Location) String() string</span></span><br><span class="line"><span class="comment">type Month</span></span><br><span class="line"><span class="comment">	func (m Month) String() string</span></span><br><span class="line"><span class="comment">type ParseError</span></span><br><span class="line"><span class="comment">	func (e *ParseError) Error() string</span></span><br><span class="line"><span class="comment">type Ticker</span></span><br><span class="line"><span class="comment">	func NewTicker(d Duration) *Ticker</span></span><br><span class="line"><span class="comment">	func (t *Ticker) Reset(d Duration)</span></span><br><span class="line"><span class="comment">	func (t *Ticker) Stop()</span></span><br><span class="line"><span class="comment">type Time</span></span><br><span class="line"><span class="comment">	func Date(year int, month Month, day, hour, min, sec, nsec int, loc *Location) Time</span></span><br><span class="line"><span class="comment">	func Now() Time</span></span><br><span class="line"><span class="comment">	func Parse(layout, value string) (Time, error)</span></span><br><span class="line"><span class="comment">	func ParseInLocation(layout, value string, loc *Location) (Time, error)</span></span><br><span class="line"><span class="comment">	func Unix(sec int64, nsec int64) Time</span></span><br><span class="line"><span class="comment">	func (t Time) Add(d Duration) Time</span></span><br><span class="line"><span class="comment">	func (t Time) AddDate(years int, months int, days int) Time</span></span><br><span class="line"><span class="comment">	func (t Time) After(u Time) bool</span></span><br><span class="line"><span class="comment">	func (t Time) AppendFormat(b []byte, layout string) []byte</span></span><br><span class="line"><span class="comment">	func (t Time) Before(u Time) bool</span></span><br><span class="line"><span class="comment">	func (t Time) Clock() (hour, min, sec int)</span></span><br><span class="line"><span class="comment">	func (t Time) Date() (year int, month Month, day int)</span></span><br><span class="line"><span class="comment">	func (t Time) Day() int</span></span><br><span class="line"><span class="comment">	func (t Time) Equal(u Time) bool</span></span><br><span class="line"><span class="comment">	func (t Time) Format(layout string) string</span></span><br><span class="line"><span class="comment">	func (t *Time) GobDecode(data []byte) error</span></span><br><span class="line"><span class="comment">	func (t Time) GobEncode() ([]byte, error)</span></span><br><span class="line"><span class="comment">	func (t Time) Hour() int</span></span><br><span class="line"><span class="comment">	func (t Time) ISOWeek() (year, week int)</span></span><br><span class="line"><span class="comment">	func (t Time) In(loc *Location) Time</span></span><br><span class="line"><span class="comment">	func (t Time) IsZero() bool</span></span><br><span class="line"><span class="comment">	func (t Time) Local() Time</span></span><br><span class="line"><span class="comment">	func (t Time) Location() *Location</span></span><br><span class="line"><span class="comment">	func (t Time) MarshalBinary() ([]byte, error)</span></span><br><span class="line"><span class="comment">	func (t Time) MarshalJSON() ([]byte, error)</span></span><br><span class="line"><span class="comment">	func (t Time) MarshalText() ([]byte, error)</span></span><br><span class="line"><span class="comment">	func (t Time) Minute() int</span></span><br><span class="line"><span class="comment">	func (t Time) Month() Month</span></span><br><span class="line"><span class="comment">	func (t Time) Nanosecond() int</span></span><br><span class="line"><span class="comment">	func (t Time) Round(d Duration) Time</span></span><br><span class="line"><span class="comment">	func (t Time) Second() int</span></span><br><span class="line"><span class="comment">	func (t Time) String() string</span></span><br><span class="line"><span class="comment">	func (t Time) Sub(u Time) Duration</span></span><br><span class="line"><span class="comment">	func (t Time) Truncate(d Duration) Time</span></span><br><span class="line"><span class="comment">	func (t Time) UTC() Time</span></span><br><span class="line"><span class="comment">	func (t Time) Unix() int64</span></span><br><span class="line"><span class="comment">	func (t Time) UnixNano() int64</span></span><br><span class="line"><span class="comment">	func (t *Time) UnmarshalBinary(data []byte) error</span></span><br><span class="line"><span class="comment">	func (t *Time) UnmarshalJSON(data []byte) error</span></span><br><span class="line"><span class="comment">	func (t *Time) UnmarshalText(data []byte) error</span></span><br><span class="line"><span class="comment">	func (t Time) Weekday() Weekday</span></span><br><span class="line"><span class="comment">	func (t Time) Year() int</span></span><br><span class="line"><span class="comment">	func (t Time) YearDay() int</span></span><br><span class="line"><span class="comment">	func (t Time) Zone() (name string, offset int)</span></span><br><span class="line"><span class="comment">type Timer</span></span><br><span class="line"><span class="comment">	func AfterFunc(d Duration, f func()) *Timer</span></span><br><span class="line"><span class="comment">	func NewTimer(d Duration) *Timer</span></span><br><span class="line"><span class="comment">	func (t *Timer) Reset(d Duration) bool</span></span><br><span class="line"><span class="comment">	func (t *Timer) Stop() bool</span></span><br><span class="line"><span class="comment">type Weekday</span></span><br><span class="line"><span class="comment">	func (d Weekday) String() string</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	Since返回从t到现在经过的时间，等价于time.Now().Sub(t)</span></span><br><span class="line"><span class="comment">    *func Since(t Time) Duration</span></span><br><span class="line"><span class="comment">        Weekday返回由t指定的星期几</span></span><br><span class="line"><span class="comment">    *func (t Time) Weekday() Weekday</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="exec（实现终端命令、脚本调用功能）"><a href="#exec（实现终端命令、脚本调用功能）" class="headerlink" title="exec（实现终端命令、脚本调用功能）"></a>exec（实现终端命令、脚本调用功能）</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Variables</span></span><br><span class="line"><span class="comment">func LookPath(file string) (string, error)</span></span><br><span class="line"><span class="comment">type Cmd</span></span><br><span class="line"><span class="comment">func Command(name string, arg ...string) *Cmd</span></span><br><span class="line"><span class="comment">func CommandContext(ctx context.Context, name string, arg ...string) *Cmd</span></span><br><span class="line"><span class="comment">func (c *Cmd) CombinedOutput() ([]byte, error)</span></span><br><span class="line"><span class="comment">func (c *Cmd) Output() ([]byte, error)</span></span><br><span class="line"><span class="comment">func (c *Cmd) Run() error</span></span><br><span class="line"><span class="comment">func (c *Cmd) Start() error</span></span><br><span class="line"><span class="comment">func (c *Cmd) StderrPipe() (io.ReadCloser, error)</span></span><br><span class="line"><span class="comment">func (c *Cmd) StdinPipe() (io.WriteCloser, error)</span></span><br><span class="line"><span class="comment">func (c *Cmd) StdoutPipe() (io.ReadCloser, error)</span></span><br><span class="line"><span class="comment">func (c *Cmd) String() string</span></span><br><span class="line"><span class="comment">func (c *Cmd) Wait() error</span></span><br><span class="line"><span class="comment">type Error</span></span><br><span class="line"><span class="comment">func (e *Error) Error() string</span></span><br><span class="line"><span class="comment">func (e *Error) Unwrap() error</span></span><br><span class="line"><span class="comment">type ExitError</span></span><br><span class="line"><span class="comment">func (e *ExitError) Error() string</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	Command返回Cmd结构以执行具有给定参数的命名程序</span></span><br><span class="line"><span class="comment">    *func Command(name string,arg ...string) *cmd</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	CommandContext类似于Command，但包含上下文，若上下文在命令本身完成之前完成，则提供的上下文用于终止进程（通过调用os.Process.Kill）</span></span><br><span class="line"><span class="comment">    *func CommandContext(ctx context.Context,name string,arg ...string) *Cmd</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    ctx, cancel := context.WithTimeout(context.Background(), <span class="number">100</span>*time.Millisecond)</span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := exec.CommandContext(ctx, <span class="string">&quot;sleep&quot;</span>, <span class="string">&quot;5&quot;</span>).Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// This will fail after 100 milliseconds. The 5 second sleep</span></span><br><span class="line">		<span class="comment">// will be interrupted.</span></span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	CombinedOutput运行命令并返回其组合的标准输出和标准错误</span></span><br><span class="line"><span class="comment">    *func (c *Cmd) CombineOutput() ([]byte,error)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://danyfield.github.io">dany</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://danyfield.github.io/2023/02/03/go%E5%8C%85/">https://danyfield.github.io/2023/02/03/go包/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://danyfield.github.io" target="_blank">dany's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/go/">go</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/02/03/go%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6%E6%8A%80%E5%B7%A7-liwenzhou/" title="go常用组件技巧_liwenzhou"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-03</div><div class="title">go常用组件技巧_liwenzhou</div></div></a></div><div><a href="/2023/02/03/gin%E6%A1%86%E6%9E%B6%E7%AC%94%E8%AE%B0/" title="gin框架笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-03</div><div class="title">gin框架笔记</div></div></a></div><div><a href="/2023/03/07/go%E7%AC%94%E8%AE%B0/" title="go笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-07</div><div class="title">go笔记</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">dany</div><div class="author-info__description">乐园还未到达，脚步怎能停下</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/danyfield"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Archive"><span class="toc-number">1.</span> <span class="toc-text">Archive</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#tar-%E5%AE%9E%E7%8E%B0tar%E6%A0%BC%E5%BC%8F%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6%E7%9A%84%E5%AD%98%E5%8F%96"><span class="toc-number">1.1.</span> <span class="toc-text">tar(实现tar格式压缩文件的存取)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Header%EF%BC%9A%E8%A1%A8%E7%A4%BAtar%E6%96%87%E4%BB%B6%E9%87%8C%E5%8D%95%E4%B8%AA%E5%A4%B4"><span class="toc-number">1.1.1.</span> <span class="toc-text">Header：表示tar文件里单个头</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Reader%EF%BC%9A%E6%8F%90%E4%BE%9B%E5%AF%B9tar%E6%A1%A3%E6%A1%88%E6%96%87%E4%BB%B6%E7%9A%84%E9%A1%BA%E5%BA%8F%E8%AF%BB%E5%8F%96"><span class="toc-number">1.1.2.</span> <span class="toc-text">Reader：提供对tar档案文件的顺序读取</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Writer%EF%BC%9A%E6%8F%90%E4%BE%9BPOSIX-1%E6%A0%BC%E5%BC%8F%E7%9A%84tar%E6%A1%A3%E6%A1%88%E6%96%87%E4%BB%B6%E9%A1%BA%E5%BA%8F%E5%86%99%E5%85%A5"><span class="toc-number">1.1.3.</span> <span class="toc-text">Writer：提供POSIX.1格式的tar档案文件顺序写入</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Zip"><span class="toc-number">1.2.</span> <span class="toc-text">Zip</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6"><span class="toc-number">1.2.1.</span> <span class="toc-text">压缩文件</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E5%B9%B6%E5%8E%8B%E7%BC%A9"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">读取文件内容并压缩</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%B0%86%E6%95%B0%E6%8D%AE%E7%9B%B4%E6%8E%A5%E5%86%99%E5%85%A5%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">将数据直接写入压缩文件</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%A7%A3%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">解压缩文件</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bufio%EF%BC%88%E5%AE%9E%E7%8E%B0%E6%9C%89%E7%BC%93%E5%86%B2%E7%9A%84I-O%EF%BC%89"><span class="toc-number">2.</span> <span class="toc-text">Bufio（实现有缓冲的I&#x2F;O）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Builtin%EF%BC%88%E4%B8%BAgo%E6%8F%90%E4%BE%9B%E4%B8%80%E4%BA%9B%E5%86%85%E7%BD%AE%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%87%BD%E6%95%B0%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">Builtin（为go提供一些内置的类型和函数）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bytes%EF%BC%88%E4%B8%BB%E8%A6%81%E6%8F%90%E4%BE%9B%E6%93%8D%E4%BD%9C%E5%AD%97%E8%8A%82%E5%88%87%E7%89%87%E7%9A%84%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95%EF%BC%89"><span class="toc-number">4.</span> <span class="toc-text">Bytes（主要提供操作字节切片的函数和方法）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Context"><span class="toc-number">5.</span> <span class="toc-text">Context</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Goroutine"><span class="toc-number">5.1.</span> <span class="toc-text">Goroutine</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Channel"><span class="toc-number">5.2.</span> <span class="toc-text">Channel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86"><span class="toc-number">5.3.</span> <span class="toc-text">设计原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Context%E6%8E%A5%E5%8F%A3"><span class="toc-number">5.4.</span> <span class="toc-text">Context接口</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#With%E7%B3%BB%E5%88%97%E5%87%BD%E6%95%B0"><span class="toc-number">5.4.1.</span> <span class="toc-text">With系列函数</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#WithCancel"><span class="toc-number">5.4.1.1.</span> <span class="toc-text">WithCancel</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#WithTimeout%E3%80%81WithDeadline"><span class="toc-number">5.4.1.2.</span> <span class="toc-text">WithTimeout、WithDeadline</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#WithValue"><span class="toc-number">5.4.1.3.</span> <span class="toc-text">WithValue</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Database"><span class="toc-number">6.</span> <span class="toc-text">Database</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#encoding"><span class="toc-number">7.</span> <span class="toc-text">encoding</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#json"><span class="toc-number">7.1.</span> <span class="toc-text">json</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Marshal"><span class="toc-number">7.1.1.</span> <span class="toc-text">Marshal</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Unmarshal"><span class="toc-number">7.1.2.</span> <span class="toc-text">Unmarshal</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fmt"><span class="toc-number">8.</span> <span class="toc-text">fmt</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%A0%BC%E5%BC%8F"><span class="toc-number">8.1.</span> <span class="toc-text">类型格式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%9A%E7%94%A8"><span class="toc-number">8.1.1.</span> <span class="toc-text">通用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%83%E5%B0%94%E5%80%BC"><span class="toc-number">8.1.2.</span> <span class="toc-text">布尔值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B4%E6%95%B0"><span class="toc-number">8.1.3.</span> <span class="toc-text">整数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E4%B8%8E%E5%A4%8D%E6%95%B0"><span class="toc-number">8.1.4.</span> <span class="toc-text">浮点数与复数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E-byte"><span class="toc-number">8.1.5.</span> <span class="toc-text">字符串与[]byte</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%87%E9%92%88"><span class="toc-number">8.1.6.</span> <span class="toc-text">指针</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%91%E5%A4%96%E8%BE%93%E5%87%BA"><span class="toc-number">8.2.</span> <span class="toc-text">向外输出</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Print"><span class="toc-number">8.2.1.</span> <span class="toc-text">Print</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Fprint"><span class="toc-number">8.2.2.</span> <span class="toc-text">Fprint</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Sprint"><span class="toc-number">8.2.3.</span> <span class="toc-text">Sprint</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E8%BE%93%E5%85%A5"><span class="toc-number">8.3.</span> <span class="toc-text">获取输入</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Scan"><span class="toc-number">8.3.1.</span> <span class="toc-text">Scan</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Scanf"><span class="toc-number">8.3.2.</span> <span class="toc-text">Scanf</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Scanln"><span class="toc-number">8.3.3.</span> <span class="toc-text">Scanln</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Fscan%E5%92%8CSscan"><span class="toc-number">8.3.4.</span> <span class="toc-text">Fscan和Sscan</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#strings-%E5%92%8C-strconv"><span class="toc-number">9.</span> <span class="toc-text">strings 和 strconv</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E5%92%8C%E5%90%8E%E7%BC%80"><span class="toc-number">9.1.</span> <span class="toc-text">前缀和后缀</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%85%E5%90%AB%E5%85%B3%E7%B3%BB"><span class="toc-number">9.2.</span> <span class="toc-text">字符串包含关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9B%BF%E6%8D%A2"><span class="toc-number">9.3.</span> <span class="toc-text">字符串替换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0"><span class="toc-number">9.4.</span> <span class="toc-text">字符串出现次数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">9.5.</span> <span class="toc-text">重复字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%A7%E5%B0%8F%E5%86%99"><span class="toc-number">9.6.</span> <span class="toc-text">修改字符串大小写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E5%89%AA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">9.7.</span> <span class="toc-text">修剪字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%89%B2%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">9.8.</span> <span class="toc-text">分割字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%BC%E6%8E%A5slice%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">9.9.</span> <span class="toc-text">拼接slice到字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%86%85%E5%AE%B9"><span class="toc-number">9.10.</span> <span class="toc-text">从字符串中读取内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E5%85%B6%E5%AE%83%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">9.11.</span> <span class="toc-text">字符串与其它类型的转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO"><span class="toc-number">10.</span> <span class="toc-text">IO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#log%EF%BC%88%E6%8F%90%E4%BE%9B%E6%97%A5%E5%BF%97%E6%93%8D%E4%BD%9C%E7%9A%84%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95%EF%BC%89"><span class="toc-number">11.</span> <span class="toc-text">log（提供日志操作的函数和方法）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sort%EF%BC%88%E6%8C%89%E7%85%A7%E4%B8%80%E5%AE%9A%E8%A7%84%E5%88%99%E5%AF%B9%E5%85%83%E7%B4%A0%E8%BF%9B%E8%A1%8C%E7%9B%B8%E5%85%B3%E6%8E%92%E5%BA%8F%EF%BC%89"><span class="toc-number">12.</span> <span class="toc-text">sort（按照一定规则对元素进行相关排序）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OS%EF%BC%88%E5%BA%95%E5%B1%82%E7%9B%B8%E5%85%B3%E7%9A%84%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95%EF%BC%89"><span class="toc-number">13.</span> <span class="toc-text">OS（底层相关的函数和方法）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#time"><span class="toc-number">14.</span> <span class="toc-text">time</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#exec%EF%BC%88%E5%AE%9E%E7%8E%B0%E7%BB%88%E7%AB%AF%E5%91%BD%E4%BB%A4%E3%80%81%E8%84%9A%E6%9C%AC%E8%B0%83%E7%94%A8%E5%8A%9F%E8%83%BD%EF%BC%89"><span class="toc-number">15.</span> <span class="toc-text">exec（实现终端命令、脚本调用功能）</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/07/go%E7%AC%94%E8%AE%B0/" title="go笔记">go笔记</a><time datetime="2023-03-07T09:55:49.000Z" title="发表于 2023-03-07 17:55:49">2023-03-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/03/wordpress%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/" title="wordpress搭建博客">wordpress搭建博客</a><time datetime="2023-03-03T03:00:27.000Z" title="发表于 2023-03-03 11:00:27">2023-03-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/02/23/TypeScript%E7%AC%94%E8%AE%B0/" title="TypeScript笔记">TypeScript笔记</a><time datetime="2023-02-23T06:18:03.000Z" title="发表于 2023-02-23 14:18:03">2023-02-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/02/13/%E5%8A%9B%E6%89%A3easy/" title="力扣easy">力扣easy</a><time datetime="2023-02-13T13:09:27.000Z" title="发表于 2023-02-13 21:09:27">2023-02-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/02/07/mysql%E7%AC%94%E8%AE%B0/" title="mysql笔记">mysql笔记</a><time datetime="2023-02-07T13:09:17.000Z" title="发表于 2023-02-07 21:09:17">2023-02-07</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 By dany</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script src="/js/jquery.js"></script><script src="/js/foot.js"></script><div class="aplayer no-destroy" data-id="8798117783" data-server="tencent" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="none" data-autoplay="false" muted></div><script id="canvas_nest" defer="defer" color="127,255,212" opacity="0.8" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>