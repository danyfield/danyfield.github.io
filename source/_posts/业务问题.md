---
title: 业务问题
date: 2023-02-03 15:14:05
---

#### Cookie、Session与Token

##### 背景

随着交互式Web应用的兴起，Web需要管理会话；此时为了区分用户分发一个会话标识（session id），即随机字符串；但此时服务器需要保存所有用户的session id，若访问量过多则会造成巨大的开销。

若用户已经登录了系统，则发送一个特定算法加密的token，里面包含了用户的user id；用户下次访问时只需通过Http header将token传递过来即可

##### Cookie

指浏览器里能永久存储的一种数据，是浏览器实现的一种数据存储功能

Cookie由服务器生成，发送给浏览器，浏览器把Cookie以kv形式保存在某个目录下的文本文件内，下一次请求同一网站时会把该Cookie发送给服务器，每个域中的Cookie数量是有限的

##### Session

即会话，区分客户端的“身份标识”；对于浏览器客户端默认用Cookie的方式保存

服务器使用Session将用户信息临时保存在服务器上，用户离开网站后Session会被销毁，该存储方式相对Cookie更安全，但Session有一个缺陷：若Web服务器做了负载均衡，则下一个操作请求到了另一台服务器的时候Session会丢失

##### Token

由特定算法和唯一密钥生成的签名和数据一起作为Token

##### 分布式Session（Session共享）

将Session存放到第三方，客户端和服务端通信时去第三方存取Session信息；

redis常作为第三方，主要由于：

1. 读写更快，其直接操作内存数据，而Cookie和Session都是以文件形式存储
2. 更好设置过期时间
3. 更好的分布式同步，设置redis主从同步，可快速同步Session到各台web服务器，比文件存储更加快速

#### 单点登录原理及实现方式

单点登录（Single Sign On）SSO，即在同一账号平台下的多个应用系统中，用户只需登录一次即可访问所有相互信任的系统

##### 单点登录原理

SSO需要一个独立的认证中心，认证中心验证用户的用户名和密码正确，创建全局会话和token，token作为参数发送给各个子系统，子系统拿到token即得到授权，返回确认信息，创建局部会话，局部会话登录方式与单系统登录方式相同

用户与SSO建立的会话为全局会话，与各个子系统建立的会话为局部会话：

1. 局部会话存在，全局会话一定存在
2. 全局会话存在，局部会话不一定存在
3. 全局会话销毁，局部会话必须销毁

![](https://img-blog.csdnimg.cn/316407c5be7d4779a23a54fbaeb5fa69.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5Y-q5qmZ5a2QMA==,size_20,color_FFFFFF,t_70,g_se,x_16)

##### 单点登录实现方式

一般包括：Cookies、session同步、分布式Session

###### 基于Cookie+Redis的单点登录

用cookie作为媒介存放用户凭证，用户登录系统后返回一个加密的cookie，当用户访问子应用的时候带上该cookie，校验通过后即可登录

redis：`key`：生成唯一随机值（ip、用户id等），`value`：用户数据

cookie：将redis中生成的key值放到cookie里

Cookie一般以域名为分割的，即a.xxx.com和b.xxx.com的Cookie不能互相访问，但是子域名可以访问上级域名的Cookie，即a.xxx.com和b.xxx.com可以访问xxx.com下的Cookie，故能将顶级域名的Cookie作为OpenId的载体

![](https://img-blog.csdnimg.cn/img_convert/8b34f12a8b8b34bfefe7c22a51d10064.png)

此方法存在安全性问题

###### 分布式session方式实现单点登录

1. 用户首次登录，将会话信息（用户Id和用户信息），如以用户Id为Key，写入分布式Session
2. 用户再次登录时获取分布式Session，是否有会话信息，若没有则跳到登录页
3. 一般采用Cache中间件实现如Redis，若分布式Session宕机后可以从持久化存储中加载会话信息
4. 存入会话时可以设置会话保持时间

###### 通过页面重定向方式

通过父应用和子应用来回重定向中进行通信，实现信息的安全传递，父应用提供一个GET方式的登录接口，用户通过子应用重定向连接方式访问该接口，若应用还未登录则返回一个登录页面，用户输入账号密码进行登录；若用户已登录，则生成加密的token，且重定向到子应用提供验证token的接口，解密和校验后，子应用登录当前用户

此方法解决的安全性问题和跨域问题，但不方便

###### 使用token实现

1. 在项目某个模块登录后，按照规则生成字符串，将登录之后用户包含到生成字符串中，把字符串返回

   1. 可以把字符串通过cookie返回
   2. 把字符串通过地址栏返回

2. 再去访问项目其它模块，每次访问在地址栏带着生成的字符串，在访问模块内获取地址字符串，根据字符串获取用户信息，若能获取到就可以登录

   ![](https://img-blog.csdnimg.cn/724392568bd544de9dd0ad456e1cf83a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATGl16aOO,size_20,color_FFFFFF,t_70,g_se,x_16)

   

##### 联通云SSO-Postmassage单点登录

![](https://s1.ax1x.com/2023/02/03/pSsty28.png)

**交互流程**

1. 用户从云径门户登录请求IAM登录认证，登陆成功后前端缓存token相关数据并保存在浏览器的缓存中
2. 点击第三方系统入口时，云径门户前端以POSTMessage等方式发送token相关数据，第三方获取并保存，反馈云径前端已成功接收
3. 用户对第三方页面操作时，第三方前端将token相关数据传给后端并校验本地会话是否过期，若过期就调用IAM进行认证
4. token认证通过，IAM返回用户信息，其后端缓存token，有效期设置10分钟
5. token认证失败，第三方后端返回其前端认证失败状态，前端弹出登录失效请重新登录提示，用户点击后需通过postMessage通知到云径前端，云径前端跳转到登录页面。通知信息包括 回调地址、系统标识
6. 登出操作在云径门户进行，因对接系统缓存有效期为10分钟，10分钟内会话不一致可以接受

**SSO登录认证API接口**

HTTP头定义

| 参数名称     | 数据类型 | 参数描述         |
| ------------ | -------- | ---------------- |
| Content-Type | String   | application/json |
| ACCESS_TOKEN | String   | token            |
| APP_KEY      | String   | 接入服务标识     |
| SIGN         | String   | 签名             |

**注意项**

- 企方将URL提供给联通云前端研发，联通云用iframe装载或跳转接入产品控制台页面用POSTMessage发送消息给接入方

- 接入产品控制台前端接受消息Sample如下：

  ```java
  window.addEventListener('message',function (e: any) {
      //接入方需要的数据如token等存放在data中
      const params = e.data;
      //WOCLOUD代表联通云的发送标识
      if (params.linkSource == "WOCLOUD") {
          //通知联通云message已经收到，联通云收到后，不再发送message
          e.source.postMessage({
              status: 200,
              data: {}
          },e.origin);
      }
      //接入方逻辑代码
  })
  ```

- token失效处理示例

  ```javascript
  iframe.postMessage({	//发送POSTMessage
      token:	"token",	//token值
      url:	"product page url",	//用户当前的路由
      linkSource："ECS"	//系统标识
  },"console.cucloud.cn/console/home");	//接收POSTMessage窗口
  ```

- 处理实例

  `loginbymessage.tpl`

  ```html
  <script>
  	window.onload = function() {
          window.addEventListener('message',msgCB,false);
      }
      msgCB = function(e){
          const params = e.data;
          if (params.linkSource == "WOCLOUD"){
              window.removeEventListener("message",msgCB,false);
              e.source.postMessage({
                  status: 200,
                  data: ''
              },e.origin);
              
              $.ajax({
                 type: "post",
                  url: "Ajax.php?module=ajax_postmessage",
                  data: e.data,
                  async: false,
                  success: function(data){
                      var object = eval("("+data+")");
                      if(object.pass == 1){
                          window.location.href=object.page;
                      }else{
                          console.log(object.msg);
                      }
                  },
                  error: function(){console.log('认证失败');}
              });
          }
      }
  </script>
  ```

  `ajax_postmessage.php`

  ```php
  <?php
      //记录云账号，区分联通云和合营云
      if($_REQUEST['linkSource'] == 'WOCLOUD')   //联通云
      	$source_id = 1;
  	elseif($_REQUEST['linkSource'] == 'WOCLOUD-HYY'){   //合营云
      	$source_id = 2;
      	//创建新cookie
      	header('Set-Cookie: apiToken=' . $_REQUEST['ApiToken'] . ';Max-Age=86400; SameSite=None; Secure',false);
      	header('Set-Cookie: regionId=' . $_REQUEST['regionId'] . ';Max-Age=86400; SameSite=None; Secure',false);
      	header('Set-Cookie: uid=' . $_REQUEST['uid'] . ';Max-Age=86400; SameSite=None; Secure',false);}
  
  	$biz_id = $_REQUEST['loginUserId'];
  	$loginname = fn_utf82gbk($_REQUEST['loginUserName']);
  	$token = trim($_REQUEST['token']);
  
  	//联通白名单验证
  	if($bizchannel->checktoken($token)){	//认证成功
          //用户账号管理
          //保存登录状态
          
          //配置samesite
      header('Set-Cookie:'. IAC_LOGINSESSION_COOKIE_NAME . '=' . $token . ';Max-Age=86400; SameSite=None; Secure',false);
      die(json_encode(array('pass'=>1, 'page'=>'/wocloud.php','can'=>implode(',',$_REQUEST))));
      }
  ```

`wocloud.php`

来源检查，认证身份，认证成功跳转至网站主办者页

###### iframe

即iframe标签，是框架的一种形式

###### postMessage

允许来自一个文档的脚本可以传递文本消息到另一个文档里的脚本，而不用管是否跨域，这项技术称为“跨文档消息传递”

postMessage可用于解决以下方面的问题：

- 页面和其打开的新窗口的数据传递
- 页面与嵌套的iframe消息传递
- 多窗口之间消息传递

**语法**

```
otherWindow.postMessage(message,targetOrigin,[transfer]);
```

1. otherWindow：其它窗口的一个引用，如iframe的contentWindow属性、执行window.open返回的窗口对象、命名过或数值索引的window.frames
2. message：要发送的数据，它将会被结构化克隆算法序列化（部分低版本浏览器只支持字符串，故发送数据最好用JSON.stringify()序列化）
3. targetOrigin：通过targetOrigin属性指定哪些窗口能接收到消息事件，其值可以是字符串"*"（表示无限制）或一个URI（若要指定和当前窗口同源的话可设置为"/"）。在发送的时候若目标窗口的协议、主机地址或端口号这三者任意一项不匹配targetOrigin提供的值，则消息不会发送

**接收消息**

若指定的源匹配的话，则当调用postMessage()方法时，在目标窗口Window对象上就会触发一个message事件

```javascript
window.addEventListener("message",(event)=>{
	var origin = event.origin;
	if (origin !== "http://example.org:8080")
        return;
},false);
```

event的属性有：

- data：从其他window传递过来的数据副本
- origin：调用postMessage时消息发送窗口的origin，如：“http://example.org:8080”
- source：对发送消息的窗口对象的引用，可以使用其在具有不同origin的两个窗口之间建立双向数据通信

#### 双因素认证

一般来说，三种不同类型的证据可以证明一个人的身份

- **秘密信息**：只有该用户知道、其他人不知道的某种信息，如密码
- **个人物品**：该用户的私人物品，如身份证、钥匙、手机等
- **生理特征**：该用户的遗传特征，如指纹、相貌、虹膜等

这些证据称为三种“因素”，因素越多，证明力就越强；双因素认证即同时需要两个因素的证据

##### 双因素认证方案

密码+手机是常见的双因素认证方案；即提供密码的同时还要提供短信验证码；但是短信也是不安全的，故密码+短信验证不是安全的双因素认证

###### TOTP（Time-based One-time Password，基于时间的一次性密码）

**主要步骤**

1. 用户开启双因素认证后，服务器生成一个密钥
2. 服务器提示用户扫码（或其它方式），将密钥保存到用户的手机；此时服务器和用户手机都有了同一把密钥（密钥只与手机绑定）
3. 用户登录时，手机客户端使用该密钥和当前时间戳生成一个哈希，有效期30s，用户在有效期内将哈希提交给服务器
4. 服务器也是用密钥和当前时间戳生成一个哈希与用户的进行比对

**如何保证30s内服务器和手机生成相同哈希**

```
TC = floor(unixtime(now)-unixtime(T0) / TS)
```

TC 表示一个时间计数器，`unixtime(now)`是当前 Unix 时间戳，`unixtime(T0)`是约定的起始时间点的时间戳，默认是`0`，也就是1970年1月1日。TS 则是哈希有效期的时间长度，默认30秒。因此，就变成下面的形式。

```
TC = floor(unixtime(now) / 30)

#此时可以计算出哈希
TOTP = HASH(SecretKey,TC)
```

**TOTP的实现**（JavaScript）

1. 安装该模块

   ```
   npm install --save 2fa
   ```

2. 生成一个32位字符的密钥

   ```
   var tfa = require('2fa');
   tfa.generateKey(32,function(err,key){console.log(key);})
   ```

3. 生成哈希

   ```
   var tc = Math.floor(Date.now() / 1000 / 30);
   var totp = tfa.generateCode(key,tc);
   console.log(totp);
   ```

   